<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>Java面试题目合集 | Hexo</title>
  <meta name="description" content="面试专栏自我介绍 面试官您好，我叫佘尚联，来自成都大学计算机学院软件工程专业，很荣幸能参加贵公司的面试，在大学期间，曾担任学习委员、学生会部长和信息安全协会会长，积极组织策划各种活动，主动配合学院和学校工作，多次获得学校一等奖学金和三好学生，也在多个信息安全比赛中获奖。个人技能方面，熟练掌握Java语言、JVM虚拟机、并发编程、java集合、MYSQL、Redis以及主流java框架如SSM和Sp">
<meta property="og:type" content="article">
<meta property="og:title" content="Java面试题目合集">
<meta property="og:url" content="https://ssllp.github.io/2023/08/01/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="面试专栏自我介绍 面试官您好，我叫佘尚联，来自成都大学计算机学院软件工程专业，很荣幸能参加贵公司的面试，在大学期间，曾担任学习委员、学生会部长和信息安全协会会长，积极组织策划各种活动，主动配合学院和学校工作，多次获得学校一等奖学金和三好学生，也在多个信息安全比赛中获奖。个人技能方面，熟练掌握Java语言、JVM虚拟机、并发编程、java集合、MYSQL、Redis以及主流java框架如SSM和Sp">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ssllp.github.io/2023/08/01/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/image-20230827152043539.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-ip-4-model.png">
<meta property="og:image" content="https://ssllp.github.io/2023/08/01/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/image-20230905201738532.png">
<meta property="og:image" content="https://ssllp.github.io/2023/08/01/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/image-20230905203905402.png">
<meta property="og:image" content="https://ssllp.github.io/2023/08/01/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/image-20230904170519854.png">
<meta property="og:image" content="https://ssllp.github.io/2023/08/01/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/image-20230902163957866.png">
<meta property="og:image" content="https://ssllp.github.io/2023/08/01/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/image-20230902171701564.png">
<meta property="og:image" content="https://ssllp.github.io/2023/08/01/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/image-20230902185902457.png">
<meta property="og:image" content="https://ssllp.github.io/2023/08/01/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/image-20230902192240458.png">
<meta property="article:published_time" content="2023-08-01T08:31:15.000Z">
<meta property="article:modified_time" content="2023-11-08T06:50:29.581Z">
<meta property="article:author" content="ssl">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ssllp.github.io/2023/08/01/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/image-20230827152043539.png">
  <!-- Canonical links -->
  <link rel="canonical" href="https://ssllp.github.io/2023/08/01/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/index.html">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.0"></head>


<body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/ssllp" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">ssllp</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">Java开发</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> ChengDu, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-books">
          <a href="/books">
            
            <i class="icon icon-book-fill"></i>
            
            <span class="menu-title">书单</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/ssllp" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://weibo.com/" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
        <li><a href="https://www.behance.net/" target="_blank" title="Behance" data-toggle=tooltip data-placement=top><i class="icon icon-behance"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E5%AD%A6%E4%B9%A0/">Java学习</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/">前端学习</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%BF%90%E7%BB%B4%E9%83%A8%E7%BD%B2/">运维部署</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A1%B9%E7%9B%AE/">项目</a><span class="category-list-count">2</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/" rel="tag">Docker</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/FilmOnline/" rel="tag">FilmOnline</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mysql/" rel="tag">Mysql</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nginx/" rel="tag">Nginx</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/" rel="tag">Spring</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringCloud/" rel="tag">SpringCloud</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/" rel="tag">Vue</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BF%90%E7%BB%B4/" rel="tag">运维</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/Docker/" style="font-size: 13px;">Docker</a> <a href="/tags/FilmOnline/" style="font-size: 13px;">FilmOnline</a> <a href="/tags/Git/" style="font-size: 13px;">Git</a> <a href="/tags/Java/" style="font-size: 14px;">Java</a> <a href="/tags/Mysql/" style="font-size: 13px;">Mysql</a> <a href="/tags/Nginx/" style="font-size: 13px;">Nginx</a> <a href="/tags/Redis/" style="font-size: 13px;">Redis</a> <a href="/tags/Spring/" style="font-size: 13.5px;">Spring</a> <a href="/tags/SpringBoot/" style="font-size: 13px;">SpringBoot</a> <a href="/tags/SpringCloud/" style="font-size: 13px;">SpringCloud</a> <a href="/tags/Vue/" style="font-size: 13px;">Vue</a> <a href="/tags/%E8%BF%90%E7%BB%B4/" style="font-size: 14px;">运维</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 13px;">面试</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">十月 2023</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">八月 2023</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">七月 2023</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">五月 2023</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">四月 2023</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">三月 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">十月 2021</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Java%E5%AD%A6%E4%B9%A0/">Java学习</a>
              </p>
              <p class="item-title">
                <a href="/2023/10/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AD%A6%E4%B9%A0/" class="title">微服务学习</a>
              </p>
              <p class="item-date">
                <time datetime="2023-10-16T06:46:10.000Z" itemprop="datePublished">2023-10-16</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E8%BF%90%E7%BB%B4%E9%83%A8%E7%BD%B2/">运维部署</a>
              </p>
              <p class="item-title">
                <a href="/2023/10/05/Nginx%E5%AD%A6%E4%B9%A0/" class="title">Nginx学习</a>
              </p>
              <p class="item-date">
                <time datetime="2023-10-05T06:44:00.000Z" itemprop="datePublished">2023-10-05</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E8%BF%90%E7%BB%B4%E9%83%A8%E7%BD%B2/">运维部署</a>
              </p>
              <p class="item-title">
                <a href="/2023/10/03/Docker%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/" class="title">Docker安装及使用</a>
              </p>
              <p class="item-date">
                <time datetime="2023-10-03T02:29:58.000Z" itemprop="datePublished">2023-10-03</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E8%BF%90%E7%BB%B4%E9%83%A8%E7%BD%B2/">运维部署</a>
              </p>
              <p class="item-title">
                <a href="/2023/08/04/Git%E5%AD%A6%E4%B9%A0/" class="title">Git学习</a>
              </p>
              <p class="item-date">
                <time datetime="2023-08-04T07:56:19.000Z" itemprop="datePublished">2023-08-04</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a>
              </p>
              <p class="item-title">
                <a href="/2023/08/01/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/" class="title">Java面试题目合集</a>
              </p>
              <p class="item-date">
                <time datetime="2023-08-01T08:31:15.000Z" itemprop="datePublished">2023-08-01</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
  <aside class="sidebar sidebar-toc collapse   in  " id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">面试专栏</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">1.1.</span> <span class="toc-text">自我介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">1.2.</span> <span class="toc-text">Java基础及面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.1.</span> <span class="toc-text">Java语言的特点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.2.</span> <span class="toc-text">说一说JVM、JRE、JDK的关系？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.3.</span> <span class="toc-text">什么是字节码？使用字节码的好处？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.4.</span> <span class="toc-text">为什么不全部使用AOT？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.5.</span> <span class="toc-text">什么是JIT即时编译？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.6.</span> <span class="toc-text">为什么说JAVA是解释和编译共存的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.7.</span> <span class="toc-text">Java和C++的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.8.</span> <span class="toc-text">注释格式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.9.</span> <span class="toc-text">标识符和关键字的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.10.</span> <span class="toc-text">移位运算符？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.11.</span> <span class="toc-text">continue、break、return？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.12.</span> <span class="toc-text">说一下java中的数据类型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.13.</span> <span class="toc-text">基本类型和包装类的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.14.</span> <span class="toc-text">为什么说几乎所有的对象都存在堆中？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.15.</span> <span class="toc-text">说一下包装类的缓存机制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.16.</span> <span class="toc-text">说一下自动装箱和拆箱？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.17.</span> <span class="toc-text">为什么浮点数会有精度丢失的风险？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.18.</span> <span class="toc-text">如何解决浮点数运算的精度丢失？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.19.</span> <span class="toc-text">成员变量和局部变量的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.20.</span> <span class="toc-text">静态变量的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.21.</span> <span class="toc-text">字符型常量和字符串常量的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.22.</span> <span class="toc-text">静态方法为什么不能调用非静态成员？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.23.</span> <span class="toc-text">静态方法和实例方法的不同？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.24.</span> <span class="toc-text">重载和重写的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.25.</span> <span class="toc-text">什么是可变长参数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.26.</span> <span class="toc-text">面向对象和面向过程的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.27.</span> <span class="toc-text">创建一个对象用什么运算符？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.28.</span> <span class="toc-text">对象相等和引用相等？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.29.</span> <span class="toc-text">如果一个类没有构造方法，可以正常运行吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.30.</span> <span class="toc-text">构造方法的特点？能不能被重写和重载呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.31.</span> <span class="toc-text">面向对象的三大特征？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.32.</span> <span class="toc-text">接口和抽象类的共同点和区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.33.</span> <span class="toc-text">深拷贝、浅拷贝、引用拷贝？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.34.</span> <span class="toc-text">Object常见方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.35.</span> <span class="toc-text">&#x3D;&#x3D;和equals的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.36.</span> <span class="toc-text">hashcode的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.37.</span> <span class="toc-text">为什么JDK要同时提供equals和hashcode？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.38.</span> <span class="toc-text">为什么重写equals一定要重写hashcode？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.39.</span> <span class="toc-text">String、StringBuilder、StringBuffer的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.40.</span> <span class="toc-text">String为什么是不可变的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.41.</span> <span class="toc-text">字符串拼接+和StringBuilder的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.42.</span> <span class="toc-text">String的equals和object的equals的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.43.</span> <span class="toc-text">字符串常量池？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.44.</span> <span class="toc-text">String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.45.</span> <span class="toc-text">String的intern方法的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.46.</span> <span class="toc-text">String 类型的变量和常量做“+”运算时发生了什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.47.</span> <span class="toc-text">说一下Java中异常的基础体系？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.48.</span> <span class="toc-text">Throwable中的方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.49.</span> <span class="toc-text">try-catch-finally?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.50.</span> <span class="toc-text">finally代码一定会执行吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.51.</span> <span class="toc-text">如何使用try-with-resource？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.52.</span> <span class="toc-text">使用异常时的注意事项？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.53.</span> <span class="toc-text">什么是泛型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.54.</span> <span class="toc-text">泛型的使用方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.55.</span> <span class="toc-text">泛型的应用场景？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.56.</span> <span class="toc-text">什么是反射？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.57.</span> <span class="toc-text">反射的应用场景？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.58.</span> <span class="toc-text">什么是注解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.59.</span> <span class="toc-text">什么是序列化和反序列化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.60.</span> <span class="toc-text">如果字段不想序列化，怎么办？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.61.</span> <span class="toc-text">为什么不使用jdk序列化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.62.</span> <span class="toc-text">java中传参都是值传递。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.63.</span> <span class="toc-text">什么是语法糖？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.64.</span> <span class="toc-text">语法糖：switch支持string</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.65.</span> <span class="toc-text">语法糖：泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.66.</span> <span class="toc-text">语法糖：自动装箱拆箱。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.67.</span> <span class="toc-text">语法糖：可变长参数。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.68.</span> <span class="toc-text">语法糖：for-each、增强for</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.69.</span> <span class="toc-text">语法糖：Lambda表达式。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.70.</span> <span class="toc-text">语法糖：try-with-resource</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.71.</span> <span class="toc-text">Stream流常见方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.72.</span> <span class="toc-text">说一下HashMap是怎么解决Hash冲突的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.73.</span> <span class="toc-text">说一下对受检查异常和非受检查异常的理解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.74.</span> <span class="toc-text">说一下JDK动态代理为什么只能代理有接口的类？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.75.</span> <span class="toc-text">说一下对象的创建过程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.76.</span> <span class="toc-text">new String(“abc”)创建了几个对象？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">1.3.</span> <span class="toc-text">集合框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.3.1.</span> <span class="toc-text">Java集合概览？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.3.2.</span> <span class="toc-text">集合API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.3.3.</span> <span class="toc-text">说说List、Set、Queue、Map的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.3.4.</span> <span class="toc-text">集合框架底层数据结构？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.3.5.</span> <span class="toc-text">HashMap底层原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.3.6.</span> <span class="toc-text">LinkedHashMap的原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.3.7.</span> <span class="toc-text">为什么要使用集合？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.3.8.</span> <span class="toc-text">怎么选用集合？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.3.9.</span> <span class="toc-text">ArrayList和Array的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.3.10.</span> <span class="toc-text">ArrayList和Vector的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.3.11.</span> <span class="toc-text">Vector和Stack的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.3.12.</span> <span class="toc-text">ArrayList可以添加null吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.3.13.</span> <span class="toc-text">ArrayList插入和删除的时间复杂度？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.3.14.</span> <span class="toc-text">LinkedList的插入删除的时间复杂度？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.3.15.</span> <span class="toc-text">LinkedList为什么不实现RandomAccess接口？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.3.16.</span> <span class="toc-text">ArrayList和LinkedList的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.3.17.</span> <span class="toc-text">Comparable和Comparator的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.3.18.</span> <span class="toc-text">Set无序和不可重复的含义？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.3.19.</span> <span class="toc-text">比较HashSet、LinkedHashSet、TreeSet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.3.20.</span> <span class="toc-text">Queue和Deuqe的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.3.21.</span> <span class="toc-text">ArrayDeque和LinkedLis的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.3.22.</span> <span class="toc-text">HashMap和HashTable的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.3.23.</span> <span class="toc-text">HashMap和HashSet？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.3.24.</span> <span class="toc-text">HashMap和TreeMap的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.3.25.</span> <span class="toc-text">HashSet如何检查重复？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.3.26.</span> <span class="toc-text">HashMap底层实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.3.27.</span> <span class="toc-text">HashMap的长度为什么是2的幂次方？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.3.28.</span> <span class="toc-text">HashMap多线程死循环问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.3.29.</span> <span class="toc-text">HashMap线程不安全问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.3.30.</span> <span class="toc-text">HashMap的遍历？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.3.31.</span> <span class="toc-text">ArrayList扩容机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.3.32.</span> <span class="toc-text">HashMap源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.3.32.1.</span> <span class="toc-text">HashMap数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.3.32.2.</span> <span class="toc-text">put</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.3.32.3.</span> <span class="toc-text">resize</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.3.33.</span> <span class="toc-text">ConcurrentHashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.3.34.</span> <span class="toc-text">ConcurrentHashMap的get需要加锁吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.3.35.</span> <span class="toc-text">ConcurrentHashMap的key和value的值为什么不能为null？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.3.36.</span> <span class="toc-text">ConcurrentHashMap的迭代器是强一致性还是弱一致性的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.3.37.</span> <span class="toc-text">jdk7和8中ConcurrentHashMap的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.3.38.</span> <span class="toc-text">为什么jdk8之后使用synchronized代替了ReentrantLock？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.3.39.</span> <span class="toc-text">CurrentHashMap的并发度是怎么设计的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.3.40.</span> <span class="toc-text">ConcurrentHashMap和HashTable的效率？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.3.41.</span> <span class="toc-text">实现线程安全的Map的方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.3.42.</span> <span class="toc-text">CopyOnWriteArrayList</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">1.4.</span> <span class="toc-text">JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.4.1.</span> <span class="toc-text">什么是Java跨平台性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.4.2.</span> <span class="toc-text">什么是JVM语言无关性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.4.3.</span> <span class="toc-text">什么是JVM的解释执行？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.4.4.</span> <span class="toc-text">什么是JIT即时编译？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.4.5.</span> <span class="toc-text">对象一定会创建在堆中吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.4.6.</span> <span class="toc-text">讲讲JVM10种垃圾回收器？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.4.7.</span> <span class="toc-text">什么是STW？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.4.8.</span> <span class="toc-text">什么是可达性分析算法和引用计数法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.4.9.</span> <span class="toc-text">讲一讲垃圾回收算法？（复制算法，标记-清除算法、标记-整理算法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.4.10.</span> <span class="toc-text">讲讲分代模型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.4.11.</span> <span class="toc-text">讲一讲CMS垃圾回收器？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.4.12.</span> <span class="toc-text">讲一下G1垃圾回收器？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.4.13.</span> <span class="toc-text">三色标记法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.4.14.</span> <span class="toc-text">Java内存区域有哪些？（堆、方法区、虚拟机栈、本地方法栈（栈帧（局部变量表、操作数栈、动态链接和方法出口））、程序计数器）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.4.15.</span> <span class="toc-text">什么是堆内存？堆内存包含哪些部分？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.4.16.</span> <span class="toc-text">什么是内存溢出（OOM）？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.4.17.</span> <span class="toc-text">什么是内存泄露（Memory Leak）？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.4.18.</span> <span class="toc-text">对象头包括什么？（对象头（对象自身的运行时数据、类型指针、数组长度）、实例数据、对齐填充）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.4.19.</span> <span class="toc-text">JVM常见参数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.4.20.</span> <span class="toc-text">如何设置堆空间的最大值？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.4.21.</span> <span class="toc-text">java8的默认的垃圾回收器？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.4.22.</span> <span class="toc-text">什么是并行垃圾收集？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.4.23.</span> <span class="toc-text">什么是STW?什么是安全点？什么是安全区域？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.4.24.</span> <span class="toc-text">CPU过高怎么排查？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.4.25.</span> <span class="toc-text">三色标记了解过吗？漏标情况怎么解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.4.26.</span> <span class="toc-text">讲一讲类加载和类加载器？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.4.27.</span> <span class="toc-text">什么是双亲委派机制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.4.28.</span> <span class="toc-text">G1收集器有哪些特点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.4.29.</span> <span class="toc-text">哪些手段排查OOM？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.4.30.</span> <span class="toc-text">java程序的执行过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.4.30.1.</span> <span class="toc-text">类加载过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.4.31.</span> <span class="toc-text">对象的创建过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">1.5.</span> <span class="toc-text">并发编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.1.</span> <span class="toc-text">什么是进程和线程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.2.</span> <span class="toc-text">描述进程和线程的关系、区别和优缺点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.3.</span> <span class="toc-text">为什么程序计数器是私有的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.4.</span> <span class="toc-text">虚拟机栈和本地方法栈为什么是私有的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.5.</span> <span class="toc-text">一句话了解方法区和堆？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.6.</span> <span class="toc-text">并发和并行的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.7.</span> <span class="toc-text">同步和异步的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.8.</span> <span class="toc-text">为什么要使用多线程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.9.</span> <span class="toc-text">使用多线程可能会有什么问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.10.</span> <span class="toc-text">什么是线程安全和线程不安全？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.11.</span> <span class="toc-text">说说线程的生命周期和状态？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.12.</span> <span class="toc-text">为什么Java的线程不区分运行态和就绪态？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.13.</span> <span class="toc-text">什么是线程上下文切换？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.14.</span> <span class="toc-text">什么是死锁？怎么避免死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.15.</span> <span class="toc-text">sleep和wait的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.16.</span> <span class="toc-text">为什么wait不定义在Thread中？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.17.</span> <span class="toc-text">可以直接调用run方法吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.18.</span> <span class="toc-text">创建线程有哪几种方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.19.</span> <span class="toc-text">继承Tread类，重写run方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.20.</span> <span class="toc-text">实现Runnable接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.21.</span> <span class="toc-text">实现Callable接口，用FutureTask包装Callable对象，其中也封装了线程的返回值，然后交给Thread运行。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.22.</span> <span class="toc-text">Thread的常用方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.23.</span> <span class="toc-text">currentThread获取到当前运行的线程。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.24.</span> <span class="toc-text">interrupted()用于添加打断标记</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.25.</span> <span class="toc-text">sleep，暂停当前线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.26.</span> <span class="toc-text">yield，让步线程，将暂时放弃CPU片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.27.</span> <span class="toc-text">getid</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.28.</span> <span class="toc-text">getname</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.29.</span> <span class="toc-text">getpriority，setpriority设置优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.30.</span> <span class="toc-text">isDaemon、setDaemon设置是否是守护线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.31.</span> <span class="toc-text">join等待线程运行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.32.</span> <span class="toc-text">run和start的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.33.</span> <span class="toc-text">线程是否可以重新启动？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.34.</span> <span class="toc-text">如何实现线程同步？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.35.</span> <span class="toc-text">说一下对JMM的了解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.36.</span> <span class="toc-text">说说JVM内存区域和JMM的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.37.</span> <span class="toc-text">说说happens-before？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.38.</span> <span class="toc-text">并发编程3特性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.39.</span> <span class="toc-text">volatile原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.40.</span> <span class="toc-text">双重校验实现单例对象？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.41.</span> <span class="toc-text">volatile可以保证原子性吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.42.</span> <span class="toc-text">什么是悲观锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.43.</span> <span class="toc-text">什么是乐观锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.44.</span> <span class="toc-text">乐观锁和悲观锁的优缺点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.45.</span> <span class="toc-text">实现乐观锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.46.</span> <span class="toc-text">乐观锁存在的问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.47.</span> <span class="toc-text">synchronized是什么，有什么作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.48.</span> <span class="toc-text">怎么使用synchronized？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.49.</span> <span class="toc-text">构造器可以加synchronized吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.50.</span> <span class="toc-text">synchronized原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.51.</span> <span class="toc-text">synchronized和volatile的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.52.</span> <span class="toc-text">ReentrantLock是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.53.</span> <span class="toc-text">公平锁和非公平锁的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.54.</span> <span class="toc-text">synchronized和ReentrantLock的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.55.</span> <span class="toc-text">ReentrantReadWriteLock是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.56.</span> <span class="toc-text">共享锁和独占锁的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.57.</span> <span class="toc-text">读锁为什么不能升级为写锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.58.</span> <span class="toc-text">StampedLock？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.59.</span> <span class="toc-text">Atomic原子类（重点）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.60.</span> <span class="toc-text">什么是原子类？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.61.</span> <span class="toc-text">有哪些原子类？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.62.</span> <span class="toc-text">原子整数基本方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.63.</span> <span class="toc-text">原子数组？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.64.</span> <span class="toc-text">原子引用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.65.</span> <span class="toc-text">字段修改器？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.66.</span> <span class="toc-text">什么是线程池？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.67.</span> <span class="toc-text">创建线程池的方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.68.</span> <span class="toc-text">为什么不使用Executors？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.69.</span> <span class="toc-text">线程池常见参数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.70.</span> <span class="toc-text">线程池饱和策略？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.71.</span> <span class="toc-text">线程池的队列？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.72.</span> <span class="toc-text">线程池的运行流程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.73.</span> <span class="toc-text">怎么给线程池命名？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.74.</span> <span class="toc-text">线程池的大小该怎么选取？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.75.</span> <span class="toc-text">Future作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.76.</span> <span class="toc-text">FutureTask</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.77.</span> <span class="toc-text">说一下线程池原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.78.</span> <span class="toc-text">Runnable VS Callable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.79.</span> <span class="toc-text">execute和submit的对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.80.</span> <span class="toc-text">shutdown和shutdownnow的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.81.</span> <span class="toc-text">AQS详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.5.81.1.</span> <span class="toc-text">什么是AQS？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.5.81.2.</span> <span class="toc-text">AQS原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.5.81.3.</span> <span class="toc-text">ReentrantLock实现原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">1.6.</span> <span class="toc-text">数据结构及算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.6.1.</span> <span class="toc-text">查找算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">二分查找</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">1.6.1.1.1.</span> <span class="toc-text">二分查找，并返回插入点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">1.6.1.1.2.</span> <span class="toc-text">搜索二维矩阵</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">1.6.1.1.3.</span> <span class="toc-text">寻找峰值</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">1.7.</span> <span class="toc-text">操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.7.1.</span> <span class="toc-text">Linux常见命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">vim相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">配置虚拟机网络</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.7.1.3.</span> <span class="toc-text">系统管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.7.1.4.</span> <span class="toc-text">文件操作命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.7.1.5.</span> <span class="toc-text">权限指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.7.1.6.</span> <span class="toc-text">防火墙命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.7.1.7.</span> <span class="toc-text">Linux实用命令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">1.7.1.7.1.</span> <span class="toc-text">快捷键</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">1.7.1.7.2.</span> <span class="toc-text">软件安装</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">1.7.1.7.3.</span> <span class="toc-text">软链接</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">1.7.1.7.4.</span> <span class="toc-text">日期和时区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">1.7.1.7.5.</span> <span class="toc-text">网络请求和下载</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">1.7.1.7.6.</span> <span class="toc-text">端口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">1.7.1.7.7.</span> <span class="toc-text">进程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">1.7.1.7.8.</span> <span class="toc-text">环境变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">1.7.1.7.9.</span> <span class="toc-text">上传和下载</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">1.7.1.7.10.</span> <span class="toc-text">压缩和解压</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.7.2.</span> <span class="toc-text">Shell编程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">1.8.</span> <span class="toc-text">计算机网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.8.1.</span> <span class="toc-text">什么是计算机网络？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.8.2.</span> <span class="toc-text">OSI七大模型?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.8.3.</span> <span class="toc-text">TCP&#x2F;IP模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.8.4.</span> <span class="toc-text">链接到显示的执行过程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.8.5.</span> <span class="toc-text">HTTP基本概念？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.8.5.1.</span> <span class="toc-text">HTTP是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.8.5.2.</span> <span class="toc-text">HTTP常见的状态码？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.8.5.3.</span> <span class="toc-text">HTTP常见字段</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.8.6.</span> <span class="toc-text">Get和Post的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.8.7.</span> <span class="toc-text">HTTP缓存？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.8.8.</span> <span class="toc-text">HTTP协议的优点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.8.9.</span> <span class="toc-text">HTTP协议缺点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.8.10.</span> <span class="toc-text">HTTP1.1VSHTTP1.0</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.8.11.</span> <span class="toc-text">HTTP1.1性能？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.8.12.</span> <span class="toc-text">HTTPS？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.8.13.</span> <span class="toc-text">HTTP和HTTPS的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.8.14.</span> <span class="toc-text">HTTPS安全实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.8.15.</span> <span class="toc-text">TCP三次握手？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">1.9.</span> <span class="toc-text">MYSQL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.9.1.</span> <span class="toc-text">SQL篇</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.1.1.</span> <span class="toc-text">DDL</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">1.9.1.1.1.</span> <span class="toc-text">数据库操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">1.9.1.1.2.</span> <span class="toc-text">数据表操作</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.1.2.</span> <span class="toc-text">DML增删改</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.1.3.</span> <span class="toc-text">DCL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.1.4.</span> <span class="toc-text">DQL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.1.5.</span> <span class="toc-text">约束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.1.6.</span> <span class="toc-text">手撕sql</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.9.2.</span> <span class="toc-text">基础篇</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.2.1.</span> <span class="toc-text">什么是元组, 码, 候选码, 主码, 外码, 主属性, 非主属性？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.2.2.</span> <span class="toc-text">数据库三范式了解吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.2.3.</span> <span class="toc-text">主键和外键？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.2.4.</span> <span class="toc-text">为什么不建议使用外键和级联？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.2.5.</span> <span class="toc-text">什么是存储过程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.2.6.</span> <span class="toc-text">drop、delete 与 truncate 区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.2.7.</span> <span class="toc-text">char和varchar的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.2.8.</span> <span class="toc-text">存储md5应该使用char还是varchar？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.2.9.</span> <span class="toc-text">为什么不要使用join连接多表？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.2.10.</span> <span class="toc-text">程序设计分为几步？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.2.11.</span> <span class="toc-text">什么是关系型数据库？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.2.12.</span> <span class="toc-text">decimal 和 float&#x2F;double 的区别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.2.13.</span> <span class="toc-text">为什么不推荐使用text和blob？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.2.14.</span> <span class="toc-text">datetime和timestamp的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.2.15.</span> <span class="toc-text">null和’’的区别？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.9.3.</span> <span class="toc-text">索引篇</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.3.1.</span> <span class="toc-text">什么是索引？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.3.2.</span> <span class="toc-text">索引的优缺点？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.3.3.</span> <span class="toc-text">Innodb和Myisam的索引实现机制有什么不同？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.3.4.</span> <span class="toc-text">一个表如果没有创建索引，会生成b+树吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.3.5.</span> <span class="toc-text">为什么不使用hash索引？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.3.6.</span> <span class="toc-text">二叉查找树、红黑树、平衡二叉树、B树、B+ 树的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.3.7.</span> <span class="toc-text">说一下B+树索引的实现原理？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.3.8.</span> <span class="toc-text">说一下聚簇索引和非聚簇索引的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.3.9.</span> <span class="toc-text">说一下聚簇索引的优缺点？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.3.10.</span> <span class="toc-text">说一下非聚簇索引的优缺点？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.3.11.</span> <span class="toc-text">说一下B+树和B树的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.3.12.</span> <span class="toc-text">Innodb的B+树是怎么产生的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.3.13.</span> <span class="toc-text">计算一个B+数能存多少条数据？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.3.14.</span> <span class="toc-text">Innodb是怎么支持范围查询的？（先查位置，确定那一页，然后利用双向指针进行查询和排序）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.3.15.</span> <span class="toc-text">为什么要遵循最左前缀原则？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.3.16.</span> <span class="toc-text">范围查找导致索引失效的原理分析？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.3.17.</span> <span class="toc-text">索引覆盖的底层原理？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.3.18.</span> <span class="toc-text">索引扫描的底层原理？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.3.19.</span> <span class="toc-text">为什么orderby走索引会失效？（筛选条件，覆盖索引，是否超出）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.3.20.</span> <span class="toc-text">MYSQL的类型转换有什么要注意的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.3.21.</span> <span class="toc-text">类型转换导致索引失效原理？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.3.22.</span> <span class="toc-text">什么是索引下推？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.3.23.</span> <span class="toc-text">什么是自适应哈希索引？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.3.24.</span> <span class="toc-text">索引一定能提高效率吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.3.25.</span> <span class="toc-text">非聚簇索引一定会回表吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.3.26.</span> <span class="toc-text">索引失效情况？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.3.27.</span> <span class="toc-text">使用索引排序的流程？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.9.4.</span> <span class="toc-text">事务篇</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.4.1.</span> <span class="toc-text">什么是事务，谈谈对事务的了解？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.4.2.</span> <span class="toc-text">ACID特性分别是怎么实现的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.4.3.</span> <span class="toc-text">并发事务的问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.4.4.</span> <span class="toc-text">不可重复读和幻读的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.4.5.</span> <span class="toc-text">有几个事务隔离级别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.4.6.</span> <span class="toc-text">并发事务的控制方式有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.4.7.</span> <span class="toc-text">MVCC内部细节？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.4.8.</span> <span class="toc-text">隔离级别是怎么实现的，怎么解决的脏读，不可重复读和幻读？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.9.5.</span> <span class="toc-text">内部结构篇</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.5.1.</span> <span class="toc-text">说一下内部结构吧？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.5.2.</span> <span class="toc-text">说一下SQL查询的执行过程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.5.3.</span> <span class="toc-text">存储引擎有哪些，默认的是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.5.4.</span> <span class="toc-text">说说存储引擎架构？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.9.6.</span> <span class="toc-text">锁篇</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.6.1.</span> <span class="toc-text">什么是锁？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.6.2.</span> <span class="toc-text">锁有哪几种？都是干什么的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.6.3.</span> <span class="toc-text">表级锁和行锁有了解吗？有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.6.4.</span> <span class="toc-text">行级锁的使用注意事项？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.6.5.</span> <span class="toc-text">介绍一下间隙锁？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.6.6.</span> <span class="toc-text">行锁是怎么实现的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.6.7.</span> <span class="toc-text">发生死锁的情况？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.6.8.</span> <span class="toc-text">解决死锁的办法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.6.9.</span> <span class="toc-text">mysql是怎么加锁的？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.9.7.</span> <span class="toc-text">日志篇</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.7.1.</span> <span class="toc-text">慢查询日志如何优化？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.7.2.</span> <span class="toc-text">binlog和redolog的区别？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.9.8.</span> <span class="toc-text">SQL优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.8.1.</span> <span class="toc-text">怎么进行SQL优化？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">1.10.</span> <span class="toc-text">Spring、SSM、SpringBoot</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.10.1.</span> <span class="toc-text">说说对Spring的了解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.10.2.</span> <span class="toc-text">说一下对Spring容器的了解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.10.3.</span> <span class="toc-text">说一下对Beanfactory的了解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.10.4.</span> <span class="toc-text">说一下对Spring IOC的理解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.10.5.</span> <span class="toc-text">Spring是怎么管理Bean的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.10.6.</span> <span class="toc-text">介绍一下Bean的作用域？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.10.7.</span> <span class="toc-text">Spring中两个id相同的bean会报错吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.10.8.</span> <span class="toc-text">说一说bean的生命周期？（说一下bean的创建过程）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.10.9.</span> <span class="toc-text">Spring怎么解决的循环依赖？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.10.10.</span> <span class="toc-text">BeanFactory和FactoryBean的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.10.11.</span> <span class="toc-text">@Autowired和@Resource的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.10.12.</span> <span class="toc-text">Spring的单例bean是线程安全的吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.10.13.</span> <span class="toc-text">说一说对AOP的理解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.10.14.</span> <span class="toc-text">SpringAOP和AspectJ AOP的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.10.15.</span> <span class="toc-text">SpringAOP的实现方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.10.16.</span> <span class="toc-text">AOP的应用场景？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.10.17.</span> <span class="toc-text">SpringAOP不能对那些类进行增强？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.10.18.</span> <span class="toc-text">JDK代理和CGLIB的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.10.19.</span> <span class="toc-text">有了CGLIB，为什么还要使用JDK动态代理呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.10.20.</span> <span class="toc-text">AOP的通知类型有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.10.21.</span> <span class="toc-text">怎么定义切面的优先级？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.10.22.</span> <span class="toc-text">Spring事务机制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.10.23.</span> <span class="toc-text">Spring如何管理事务？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.10.24.</span> <span class="toc-text">Spring的事务传播方式有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.10.25.</span> <span class="toc-text">Spring事务和分布式事务的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.10.26.</span> <span class="toc-text">@Transactional(rollbackFor &#x3D; Exception.class)注解了解吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.10.27.</span> <span class="toc-text">什么是MVC？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.10.28.</span> <span class="toc-text">Dao层是用来做什么的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.10.29.</span> <span class="toc-text">说说对SpringMVC的理解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.10.30.</span> <span class="toc-text">介绍一下SpringMVC的工作流程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.10.31.</span> <span class="toc-text">说一下springMvc的核心组件？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.10.32.</span> <span class="toc-text">说一说知道的SpringMVC的注解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.10.33.</span> <span class="toc-text">介绍一下SpringMVC拦截器？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.10.34.</span> <span class="toc-text">过滤器和拦截器的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.10.35.</span> <span class="toc-text">怎么做统一异常处理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.10.36.</span> <span class="toc-text">SpringBoot常用注解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.10.37.</span> <span class="toc-text">谈谈对SpringBoot的理解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.10.38.</span> <span class="toc-text">SpringBoot中的starter有什么作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.10.39.</span> <span class="toc-text">Spring中Conditional的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.10.40.</span> <span class="toc-text">SpringBoot的起步流程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.10.41.</span> <span class="toc-text">描述一下自动配置原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.10.42.</span> <span class="toc-text">怎么解决SpringBoot中的跨域问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.10.43.</span> <span class="toc-text">#{}和${}的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.10.44.</span> <span class="toc-text">xml 映射文件中，除了常见的 select、insert、update、delete 标签之外，还有哪些标签？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.10.45.</span> <span class="toc-text">Mybatis的优缺点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.10.46.</span> <span class="toc-text">xml 映射文件中，除了常见的 select、insert、update、delete 标签之外，还有哪些标签？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.10.47.</span> <span class="toc-text">Dao的工作原理是什么？Dao中的方法可以重载吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.10.48.</span> <span class="toc-text">如何进行主键回填？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">1.11.</span> <span class="toc-text">Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.1.</span> <span class="toc-text">什么是Redis？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.2.</span> <span class="toc-text">Redis快的原因？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.3.</span> <span class="toc-text">Redis和Memcached的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.4.</span> <span class="toc-text">为什么使用Redis做缓存？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.5.</span> <span class="toc-text">Redis特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.6.</span> <span class="toc-text">为什么要使用Redis？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.7.</span> <span class="toc-text">Redis数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.8.</span> <span class="toc-text">五种基本类型的底层实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.9.</span> <span class="toc-text">redis中如何用跳表来存储的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.10.</span> <span class="toc-text">删除key会阻塞redis吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.11.</span> <span class="toc-text">String的应用场景有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.12.</span> <span class="toc-text">String存储对象好还是Hash存储对象好？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.13.</span> <span class="toc-text">String的底层实现是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.14.</span> <span class="toc-text">购物车信息用Hash存储好还是String？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.15.</span> <span class="toc-text">使用Redis实现排行榜怎么做？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.16.</span> <span class="toc-text">Set的应用场景是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.17.</span> <span class="toc-text">使用Set实现抽奖怎么做？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.18.</span> <span class="toc-text">使用BitMap统计活跃用户怎么做？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.19.</span> <span class="toc-text">使用HyperLogLog统计百万UV怎么做？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.20.</span> <span class="toc-text">什么是缓存穿透？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.21.</span> <span class="toc-text">缓存穿透怎么解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.22.</span> <span class="toc-text">什么是缓存击穿？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.23.</span> <span class="toc-text">什么是缓存雪崩？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.24.</span> <span class="toc-text">怎么解决缓存雪崩？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.25.</span> <span class="toc-text">怎么解决缓存击穿？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.26.</span> <span class="toc-text">数据库和缓存怎么保证一致性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.27.</span> <span class="toc-text">Redis到底是单线程还是多线程的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.28.</span> <span class="toc-text">什么是Redis持久化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.29.</span> <span class="toc-text">什么是RDB？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.30.</span> <span class="toc-text">RDB的流程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.31.</span> <span class="toc-text">RDB会什么时候执行?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.32.</span> <span class="toc-text">什么是AOF？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.33.</span> <span class="toc-text">AOF缺陷？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.34.</span> <span class="toc-text">AOF流程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.35.</span> <span class="toc-text">AOF VS RDB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.36.</span> <span class="toc-text">AOF为什么是执行命令之后再记录？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.37.</span> <span class="toc-text">AOF重写了解吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.38.</span> <span class="toc-text">持久化的策略怎么选取？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.39.</span> <span class="toc-text">主节点宕机导致全部数据丢失？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.40.</span> <span class="toc-text">线上的redis怎么备份？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.41.</span> <span class="toc-text">Redis集群</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.42.</span> <span class="toc-text">主从数据一致原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.43.</span> <span class="toc-text">主从节点之间是长链接还是短连接？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.44.</span> <span class="toc-text">主从复制风暴？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.45.</span> <span class="toc-text">为什么要有哨兵机制，哨兵是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.46.</span> <span class="toc-text">怎么判断主节点是不是真正的宕机了？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.47.</span> <span class="toc-text">由那个哨兵来进行故障转移呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.48.</span> <span class="toc-text">为什么哨兵至少设置3个？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.49.</span> <span class="toc-text">故障转移过程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.50.</span> <span class="toc-text">redis主从是同步复制，还是异步复制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.51.</span> <span class="toc-text">网络抖动导致主从频繁切换？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.52.</span> <span class="toc-text">主从切换导致缓存雪崩？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.53.</span> <span class="toc-text">分片集群？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.54.</span> <span class="toc-text">散列插槽？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.55.</span> <span class="toc-text">Redis如何判断key在哪个实例？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.56.</span> <span class="toc-text">如何将同一类数据固定的保存在同一个redis实例中？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.57.</span> <span class="toc-text">集群伸缩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.58.</span> <span class="toc-text">集群故障转移</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.59.</span> <span class="toc-text">主从VS哨兵VS集群</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.60.</span> <span class="toc-text">Redis集群是怎么进行分片的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.61.</span> <span class="toc-text">集群支持批量操作吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.62.</span> <span class="toc-text">内存回收策略？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.63.</span> <span class="toc-text">过期删除策略中Redis怎么知道key是否过期?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.64.</span> <span class="toc-text">redis死循环阻塞问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.65.</span> <span class="toc-text">内存淘汰策略？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.66.</span> <span class="toc-text">为什么没有设置过期时间，redis数据却没有了？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.67.</span> <span class="toc-text">LRU和LFU的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.68.</span> <span class="toc-text">String</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.69.</span> <span class="toc-text">Hash</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.70.</span> <span class="toc-text">list</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.71.</span> <span class="toc-text">set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.72.</span> <span class="toc-text">sorted_set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.73.</span> <span class="toc-text">BitMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.74.</span> <span class="toc-text">HyperLogLog</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.75.</span> <span class="toc-text">GEO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.11.76.</span> <span class="toc-text">Stream</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">1.12.</span> <span class="toc-text">前端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">1.13.</span> <span class="toc-text">项目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.13.1.</span> <span class="toc-text">FilmOnline</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.13.1.1.</span> <span class="toc-text">介绍一下项目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.13.1.2.</span> <span class="toc-text">需求分析？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.13.1.3.</span> <span class="toc-text">功能分析？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.13.1.4.</span> <span class="toc-text">短信验证登录的逻辑？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.13.1.5.</span> <span class="toc-text">请求限流怎么做的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.13.1.6.</span> <span class="toc-text">项目中都哪些地方用了缓存？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.13.1.7.</span> <span class="toc-text">秒杀系统设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.13.1.8.</span> <span class="toc-text">超卖问题怎么解决的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.13.1.9.</span> <span class="toc-text">一人一单问题怎么解决？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.13.1.10.</span> <span class="toc-text">数据库表创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.13.1.11.</span> <span class="toc-text">实现拦截器登录校验</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.13.1.12.</span> <span class="toc-text">实现文件上传</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.13.1.13.</span> <span class="toc-text">员工表CRUD（只有admin有修改和新增以及禁用权限）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.13.1.14.</span> <span class="toc-text">电影表CRUD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.13.1.15.</span> <span class="toc-text">拦截器链设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.13.1.16.</span> <span class="toc-text">优惠券表的CRUD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.13.1.17.</span> <span class="toc-text">公共字段填充</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.13.1.18.</span> <span class="toc-text">日志记录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.13.1.19.</span> <span class="toc-text">实现优惠券秒杀</span></a></li></ol></li></ol></li></ol></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-Java面试题目合集" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      Java面试题目合集
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2023/08/01/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/" class="article-date">
	  <time datetime="2023-08-01T08:31:15.000Z" itemprop="datePublished">2023-08-01</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link-link" href="/tags/Java/" rel="tag">Java</a>, <a class="article-tag-link-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a>
  </span>


        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2023/08/01/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/#comments" class="article-comment-link">评论</a></span>
        
      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1><span id="面试专栏">面试专栏</span></h1><h2><span id="自我介绍">自我介绍</span></h2><blockquote>
<p>面试官您好，我叫佘尚联，来自成都大学计算机学院软件工程专业，很荣幸能参加贵公司的面试，在大学期间，曾担任学习委员、学生会部长和信息安全协会会长，积极组织策划各种活动，主动配合学院和学校工作，多次获得学校一等奖学金和三好学生，也在多个信息安全比赛中获奖。个人技能方面，熟练掌握Java语言、JVM虚拟机、并发编程、java集合、MYSQL、Redis以及主流java框架如SSM和SpringBoot等，具备一定的开发和项目经验。在贵公司的空中宣讲会中了解到了贵公司的诸多业务领域和发展状况，也是由衷的希望可以加入这样一个持续发展、工作环境友好的公司，期望能与贵公司更进一步的交流，谢谢。</p>
</blockquote>
<blockquote>
<p>您好，我叫佘尚联，来自成都大学计算机学院软件工程专业，在大学期间，曾担任学习委员、学生会部长和信息安全协会会长，积极组织策划各种活动，主动配合学院和学校工作，多次获得学校一等奖学金和三好学生，也在多个信息安全比赛中获奖。</p>
<p>​         个人技能方面，熟练掌握Java语言、JVM虚拟机、并发编程、java集合、MYSQL、Redis、RabbitMQ以及主流java框架如SSM和SpringBoot等，对Html、CSS、JS、Ajax、axios、Vue等前端也有所了解使用，具备一定的开发和项目经验，这是我的简历，期待与贵公司有进一步的联系。</p>
</blockquote>
<blockquote>
<p>面试官您好，我叫佘尚联，很荣幸能参加贵公司的面试，我来自成都大学计算机学院软件工程专业，在大学期间曾担任过学习委员、学生会部长和信息安全协会的会长，多次参加信息安全大赛并获奖，在校成绩优异，多次获得一等奖学金和三好学生等荣誉，有较强的学习能力，多次担任项目组长，有多个java项目经验，同时也了解python语言和前端开发知识，进行过Django开发、深度学习项目开发以及微信小程序的开发。学习之余的爱好就是打篮球和健身，来缓解学习压力并强身健体，以上就是我的自我介绍，谢谢。</p>
</blockquote>
<h2><span id="java基础及面向对象">Java基础及面向对象</span></h2><h3><span id="java语言的特点">Java语言的特点？</span></h3><blockquote>
<p>简单易学：实现简单的程序是比较快的</p>
<p>面向对象：具备封装继承多态的特性，符合人的思维模式，便于开发。</p>
<p>支持多线程</p>
<p>安全、可靠：有访问修饰符保证安全</p>
<p>平台无关性</p>
<p>可移植性</p>
<p>解释与编译并存</p>
</blockquote>
<h3><span id="说一说jvm-jre-jdk的关系">说一说JVM、JRE、JDK的关系？</span></h3><blockquote>
<p>JDK是提供给开发者的JAVA SDK，用于创建和编译java程序，其中包含了JRE运行时环境和相关的java工具，比如javac、jdb、javadoc，JRE是java运行时环境，其中包括java核心类库和JVM，JVM即java虚拟机，是java实现跨平台的关键，java程序运行前会先经过编译，编译为class字节码文件，jvm用来将字节码转换为不同平台下的机器码并进行运行。</p>
</blockquote>
<h3><span id="什么是字节码使用字节码的好处">什么是字节码？使用字节码的好处？</span></h3><blockquote>
<p>在java中，可以被jvm理解的代码就是字节码，字节码它不针对任何处理器，只面向jvm，java采用字节码的方式，保留了解释型语言的可移植性特点，又解决了传统解释型语言执行效率低的问题，由于字节码文件是平台无关的，所以只要在相应的机器上安装了对应的jvm，就可以运行，这也是java可以一次编写多次运行和跨平台的原因。</p>
</blockquote>
<h3><span id="为什么不全部使用aot">为什么不全部使用AOT？</span></h3><blockquote>
<p>AOT 即提前编译，可以节省程序的启动时间，但是java是动态特性的，当我们使用动态代理技术时，比如在我们使用SpringAOP的时候要用到CGLIB动态代理，是一种字节码修改技术，使用AOT就会影响Java的动态特性，所以采用JIT即时编译的方式。</p>
</blockquote>
<h3><span id="什么是jit即时编译">什么是JIT即时编译？</span></h3><blockquote>
<p>在JVM中，提供了一个即时编译器，当代码被jvm判定为是热点代码时，就会走即时编译，一次性将字节码编译为机器码保存至方法区中，下次就可以直接使用。这也是说java是解释和编译共存了。</p>
</blockquote>
<h3><span id="为什么说java是解释和编译共存的">为什么说JAVA是解释和编译共存的？</span></h3><blockquote>
<p>解释型语言是逐行将代码解释为机器码，执行效率慢，但开发效率高，比较常见的就是：JavaScript、PHP、Python</p>
<p>编译型语言是一次性将代码编译为机器码，执行效率快，开发效率慢，例如：C++、C、GO</p>
<p>在java程序运行前，会先被编译器编译为class字节码文件，然后交给jvm进行逐行解释转换为机器码并运行，所以说java有解释型语言的特点，也有编译型语言的特点，而且jvm中有jit即时编译器，在判断为热点代码时，会一次性编译为机器码保存到方法区。</p>
</blockquote>
<h3><span id="java和c的区别">Java和C++的区别？</span></h3><blockquote>
<p>Java 和C++都是面向对象的语言，不过有很大区别</p>
<p>Java摈弃了C++中指针的概念，不允许直接对内存进行操纵，保证了内存的安全</p>
<p>JAVA是单继承，C++可以多继承</p>
<p>Java有独特的垃圾回收机制，不需要手动释放无用内存</p>
</blockquote>
<h3><span id="注释格式">注释格式？</span></h3><blockquote>
<p>单行注释、多行注释、文档注释</p>
<p>注释并不是越多越好的，应追求好的编程习惯和命名方式</p>
</blockquote>
<h3><span id="标识符和关键字的区别">标识符和关键字的区别？</span></h3><blockquote>
<p>标识符是一个标识名称，关键字是被赋予了特殊含义的标识符。</p>
<p>true、false、null是字面量，不是标识符。</p>
</blockquote>
<h3><span id="移位运算符">移位运算符？</span></h3><blockquote>
<p>&lt;&lt;左移，&gt;&gt;逻辑右移，&gt;&gt;&gt;算术右移</p>
<p>&lt;&lt;左移，高位丢弃，低位补0</p>
<p>‘&gt;&gt;’带符号右移,高位补符号位</p>
<p>‘&gt;&gt;&gt;’无符号右移，高位补0</p>
<p>移位操作只支持int和long</p>
</blockquote>
<h3><span id="continue-break-return">continue、break、return？</span></h3><blockquote>
<p>continue是跳出当前循环，进入下一轮循环</p>
<p>break是结束循环，return是作为方法的返回</p>
</blockquote>
<h3><span id="说一下java中的数据类型">说一下java中的数据类型？</span></h3><blockquote>
<p>数据类型分为基本数据类型和引用数据类型。</p>
<p>java是纯净的面向对象的语言，但是为了照顾程序员的编程习惯，还是引入了8种基本数据类型，包括byte、short、int、long四种整型，char字符型，flout、double浮点型和boolean类型。引用类型则包括数组、接口、类。</p>
<p>byte：1字节 ### short：2字节 ### int：4字节 ### long：8字节 ### char：2字节 flout：4字节 double：8字节</p>
<p>-2^n~~2^n-1</p>
</blockquote>
<h3><span id="基本类型和包装类的区别">基本类型和包装类的区别？</span></h3><blockquote>
<p>java是纯净的面向对象语言，但为了照顾程序员的开发习惯，依旧引入了基本类型，但是基本类型并不具备对象的特点，在很多时候不适用，所以各个基本数据类型都有自己的包装类。</p>
<p>区别在于：</p>
<ul>
<li>基本数据类型不具备对象的特点，不能用作泛型</li>
<li>基本数据类型如果是成员变量的话存放在栈中，而包装类是引用类型，基本上所有的实例对象都放在堆中</li>
<li>基本数据类型有不为null默认值，包装类默认值为null</li>
<li>基本类型比较==，比较值，包装类==比较的是地址</li>
</ul>
</blockquote>
<h3><span id="为什么说几乎所有的对象都存在堆中">为什么说几乎所有的对象都存在堆中？</span></h3><blockquote>
<p>在HotSpot引入JIT即时编译器之后，我们的jvm会在多次运行后对热点代码进行判断，如果是热点代码就会走jit即时编译，之后进行逃逸分析，如果该对象未逃逸出方法外，则可以通过标量替换的方式将对象拆解为一个个的变量存放在栈中。</p>
</blockquote>
<h3><span id="说一下包装类的缓存机制">说一下包装类的缓存机制？</span></h3><blockquote>
<p>八中基本数据类型所对应的包装类都有缓存机制进行优化，在包装类中会有一个静态类，其中用数组的方式存储了一定范围内的包装类对象，当我们进行自动装箱，调用Valueof时，如果数据范围在这个范围之间则会从数组中获取到对象，避免了对象的重复创建。</p>
</blockquote>
<h3><span id="说一下自动装箱和拆箱">说一下自动装箱和拆箱？</span></h3><blockquote>
<p>自动装箱和自动拆箱就是基本数据类型和包装类之间进行相互转换的过程，自动装箱其实就是调用了包装类的valueof方法，自动拆箱则是调用的xxxvalue方法，比如intvalue。</p>
<p>频繁的拆箱和装箱会影响性能，应避免不必要的拆箱和装箱</p>
</blockquote>
<h3><span id="为什么浮点数会有精度丢失的风险">为什么浮点数会有精度丢失的风险？</span></h3><blockquote>
<p>在二进制中，浮点数并不能被很好的表示</p>
<p>比如我们看0.2</p>
<p>0.2*2=0.4 0</p>
<p>0.4*2=0.8 0</p>
<p>0.8*2=1.6 1</p>
<p>0.6*2=1.2 1</p>
<p>0.2*2=0.4 0</p>
<p>。。。。</p>
<p>二进制的宽度是有限的，所以只能采用截取的方式，所以会有精度损失</p>
</blockquote>
<h3><span id="如何解决浮点数运算的精度丢失">如何解决浮点数运算的精度丢失？</span></h3><blockquote>
<p>使用BigDecimal类型进行浮点数运算，BigDecimal会记录整数也会记录精度，可以保证浮点运算的精度不丢失。</p>
<p>BigDecimal使用equals时不仅会比较值，还会比较精度，所以不能使用equals判断是否相等，应该使用compareTo来比较。</p>
</blockquote>
<h3><span id="成员变量和局部变量的区别">成员变量和局部变量的区别？</span></h3><blockquote>
<ul>
<li>定义位置不同：成员变量定义在类范围中，局部变量定义在方法内。</li>
<li>成员变量可以被访问修饰符和static等修饰，局部变量不行</li>
<li>成员变量有默认值初始值，局部变量必须进行初始化</li>
<li>静态成员变量存放在堆中，非静态成员变量存放在栈中，局部变量存放在栈上</li>
<li>成员变量的生命周期是对象，随对象消亡而消亡，而局部变量的生命周期是方法，方法结束时就会消亡</li>
</ul>
</blockquote>
<h3><span id="静态变量的作用">静态变量的作用？</span></h3><blockquote>
<p>静态变量被static修饰，可以被所有实例共享，只会被分配一次内存，比较节省空间。</p>
</blockquote>
<h3><span id="字符型常量和字符串常量的区别">字符型常量和字符串常量的区别？</span></h3><blockquote>
<p>字符常量是单引号引起的一个字符，字符串常量是双引号，字符常量占2字节，字符常量占若干字节。</p>
</blockquote>
<h3><span id="静态方法为什么不能调用非静态成员">静态方法为什么不能调用非静态成员？</span></h3><blockquote>
<p>静态方法在类加载阶段就被分配内存，而非静态成员必须在实例化对象后才会分配内存，所以通过静态方法调用未分配内存的变量非法操作。</p>
</blockquote>
<h3><span id="静态方法和实例方法的不同">静态方法和实例方法的不同？</span></h3><blockquote>
<p>静态方法在类加载阶段分配内存，实例方法只有创建对象时才分配内存，静态方法一般通过类名加方法名访问，实例方法通过对象名加方法名进行访问，静态方法只能访问静态成员，不能访问实例成员，实例方法即可以访问静态也可以访问非静态成员。</p>
</blockquote>
<h3><span id="重载和重写的区别">重载和重写的区别？</span></h3><blockquote>
<p>重载发生在同一个类中，相同的方法名因为参数列表的不同而执行不同的逻辑。</p>
<p>重写发生在父子类中，是子类对父类方法进行重新书写修改逻辑。</p>
<p>重载是编译时多态，重写是运行时多态</p>
<p>重载是方法名相同，参数列表不同，和返回值和访问权限无关，重写必须保证方法名相同、参数列表相同，返回值类型和抛出异常小于等于父类，修饰权限大于等于父类</p>
</blockquote>
<h3><span id="什么是可变长参数">什么是可变长参数？</span></h3><blockquote>
<p>可变长参数是一种语法糖，其实相当于是传递了一个数组，在我们不确定要传入多少个参数时，我们可以使用可变长参数来传递，需要注意发生重载时是优先匹配固定参数</p>
</blockquote>
<h3><span id="面向对象和面向过程的区别">面向对象和面向过程的区别？</span></h3><blockquote>
<p>面向对象和面向过程解决问题的方式不同，面向过程是使用方法的形式，一步步的执行解决问题。面向对象是将问题抽象为一个个对象，通过对象执行方法的方式解决问题。二者相互结合。面向对象的开发更易于维护和扩展复用。</p>
</blockquote>
<h3><span id="创建一个对象用什么运算符">创建一个对象用什么运算符？</span></h3><blockquote>
<p>使用new创建对象，对象引用放在栈中，对象实例放在堆中，一个引用对应1个或0个对象，一个对象可以有多个引用。</p>
</blockquote>
<h3><span id="对象相等和引用相等">对象相等和引用相等？</span></h3><blockquote>
<p>对象相等是指的存放内容相等</p>
<p>引用相等是指内存地址相同</p>
</blockquote>
<h3><span id="如果一个类没有构造方法可以正常运行吗">如果一个类没有构造方法，可以正常运行吗？</span></h3><blockquote>
<p>如果没有构造方法，会自动生成无参构造方法</p>
</blockquote>
<h3><span id="构造方法的特点能不能被重写和重载呢">构造方法的特点？能不能被重写和重载呢？</span></h3><blockquote>
<p>构造方法与类名相同，构造方法没有返回值，也不能被void修饰，构造方法不能被重写，因为必须和类名相同，构造方法可以被重载。</p>
</blockquote>
<h3><span id="面向对象的三大特征">面向对象的三大特征？</span></h3><blockquote>
<p>封装、继承、多态</p>
<p>封装指的是，将代码的细节隐藏起来，不允许外部直接访问内部的信息，只能通过暴露出来的接口去进行访问，起到数据保密、信息安全的目的。</p>
<p>继承指的是，通过已有的类模板去创建新类的过程，保证了java的可重用性和可扩展性，提高开发效率，子类会继承父类的所有方法和属性，但是不能访问私有属性。</p>
<p>多态指的是一个对象的不同运行结果，分为运行时多态和编译时多态，编译时多态即重载，运行时多态则是需要满足父子类继承关系、必须重写了方法、父类引用指向子类实例。通过子类对父类方法进行了重写，则调用子类方法，如果没有重写则调用父类方法。</p>
<p>多态的缺点是不能调用子类的特有方法。</p>
</blockquote>
<h3><span id="接口和抽象类的共同点和区别">接口和抽象类的共同点和区别？</span></h3><blockquote>
<p>接口和抽象类都不能被实例化，二者内都可以有抽象方法，是实现代码复用和扩展的重要手段。</p>
<p>接口中没有构造方法，抽象类可以有构造方法</p>
<p>接口全都是抽象方法，抽象类可以有普通方法</p>
<p>接口可以多继承，抽象类只能单继承</p>
<p>抽象类可以有普通成员变量，接口中的变量只能是常量。</p>
</blockquote>
<h3><span id="深拷贝-浅拷贝-引用拷贝">深拷贝、浅拷贝、引用拷贝？</span></h3><blockquote>
<p>浅拷贝指的是创建一个新的对象，但是对象内部如果有其他引用类型的话，会拷贝其地址，使用的同一个引用对象。object中的clone方法就是浅拷贝</p>
<p>深拷贝指的是完整的复制出原本对象的副本，包括其中的内部引用。使用的不是同一个内部对象。</p>
<p>引用拷贝只是将引用复制过来，指向同一个对象。</p>
</blockquote>
<h3><span id="object常见方法">Object常见方法？</span></h3><blockquote>
<p>clone、wait、tostring、getclass、notify、notifyall、equals、hashcode、finalize</p>
</blockquote>
<h3><span id="和equals的区别">==和equals的区别？</span></h3><blockquote>
<p>基本数据类型时，==比较值，引用类型时，==比较地址</p>
<p>equals没有重写时，与==一样比较地址，重写后比较内容是否相等。</p>
</blockquote>
<h3><span id="hashcode的作用">hashcode的作用？</span></h3><blockquote>
<p>hashcode是获取到对象的哈希码，可以决定对象在哈希表中的位置，可以减少我们equals的比较次数，比如我们在hashset插入元素时，我们会通过hash值和set长度-1进行与运算，算出在数组中的索引位置，如果相同的话就用equals进一步比较是否是真正的相同，相同则替换，不相同则插入到链表中。</p>
</blockquote>
<h3><span id="为什么jdk要同时提供equals和hashcode">为什么JDK要同时提供equals和hashcode？</span></h3><blockquote>
<p>equals和hashcode都是用来比较对象的，hashcode会根据特定的hash算法来算出哈希码，hash码不同的对象一定不相同，但是会有hash冲突的情况，即hash值相同但对象不同，equals相同的对象，hashcode也一定相同。同时使用hashcode和equals，可以提高比较速度，在很多容器中都是先比较hashcode再比较equals的。</p>
</blockquote>
<h3><span id="为什么重写equals一定要重写hashcode">为什么重写equals一定要重写hashcode？</span></h3><blockquote>
<p>这是为了保证，equals相等的对象hashcode也一定相等，如果重写equals没有重写hashcode的话，hashcode是object的hashcode，是根据地址值计算的，那么equals相同的对象，可能hashcode也会不同，在hashmap计算索引位置时就会插入两个相同的元素。</p>
</blockquote>
<h3><span id="string-stringbuilder-stringbuffer的区别">String、StringBuilder、StringBuffer的区别？</span></h3><blockquote>
<p>String是不可变类，底层是静态数组，StringBuilder和StringBuffer都是可变字符串类，其内部有很多的字符串操作方法，比如append等。String是不可变类，是线程安全的，StringBuffer内部加了同步锁，是线程安全的，StringBuilder是线程不安全的。String每次对字符串的修改都会创建新的String对象。</p>
<p>在操作比较少的情况下使用String，操作比较频繁的情况下，如果是多线程则使用StringBuffer、单线程则使用StringBuilder，StringBuilder相对来说性能会高一点。</p>
</blockquote>
<h3><span id="string为什么是不可变的">String为什么是不可变的？</span></h3><blockquote>
<p>一方面String是被final修饰的，所以不能被继承，就不会导致被篡改，其次字符数组也是被private final修饰的，不能被改变，而且String中并没有提供对字符数组进行修改的方法。</p>
</blockquote>
<h3><span id="字符串拼接和stringbuilder的区别">字符串拼接+和StringBuilder的区别？</span></h3><blockquote>
<p>实际上+是重载运算符，实际上调用的是StringBuilder中的append方法，拼接完成调用tostring返回一个新的对象。在我们进行循环拼接的时候，用+来拼接会导致创建过渡的StringBuilder来进行拼接操作，而且会导致大量的无用对象产生。不过该问题似乎在jdk9之后就解决了。</p>
</blockquote>
<h3><span id="string的equals和object的equals的区别">String的equals和object的equals的区别？</span></h3><blockquote>
<p>String重写了equals，所以比较的是字符串的内容，而object比较的是内存地址。</p>
</blockquote>
<h3><span id="字符串常量池">字符串常量池？</span></h3><blockquote>
<p>字符串常量池是java为了提高性能减少内存损耗对字符串进行的优化，避免字符串的重复创建。</p>
</blockquote>
<h3><span id="string-s1-new-stringabc这句话创建了几个字符串对象">String s1 = new String(“abc”);这句话创建了几个字符串对象？</span></h3><blockquote>
<p>常量池创建“abc”、new String 创建一个</p>
<p>一共2个</p>
</blockquote>
<h3><span id="string的intern方法的作用">String的intern方法的作用？</span></h3><blockquote>
<p>intern会返回在字符串常量池中的引用，如果没有该应用，就将当前引用创建在常量池中。</p>
</blockquote>
<h3><span id="string-类型的变量和常量做运算时发生了什么">String 类型的变量和常量做“+”运算时发生了什么？</span></h3><blockquote>
<p>对于常量和常量相加，则只会在字符串常量池中创建一个对象，这是因为java的一种优化，对于编译期间可以确定的字符串，就可以解存入到字符串常量池。但是变量和常量进行拼接时是无法确定的，所以会调用StringBuilder的append方法进行拼接，返回string新对象。</p>
</blockquote>
<h3><span id="说一下java中异常的基础体系">说一下Java中异常的基础体系？</span></h3><blockquote>
<p>java中异常体系可以分为Exception和Error两类，都继承自Throwable类，Exception是可以被处理的异常，error是错误，比如OOM和SOF等错误。Exception又可以分为运行时异常和编译时异常，编译时异常必须要我们手动处理，运行时异常可以被自动处理。RuntimeException下面的异常都是运行时异常，即不受检查异常，例如空指针异常、数组越界异常、格式转换异常、算是错误等，其他的比如IO异常和SQL异常都是编译时异常。</p>
</blockquote>
<h3><span id="throwable中的方法">Throwable中的方法？</span></h3><blockquote>
<p>getMessage获取错误信息</p>
<p>tostring，详细信息</p>
<p>printStackTrace：控制台打印</p>
</blockquote>
<h3><span id="try-catch-finally">try-catch-finally?</span></h3><blockquote>
<p>常用于捕获异常，try是可能发生异常的代码块，catch是处理异常，finally是必须执行的代码块，常用于资源的释放。finally会在try的return之前执行。</p>
</blockquote>
<h3><span id="finally代码一定会执行吗">finally代码一定会执行吗？</span></h3><blockquote>
<p>一般是一定执行，但是如果在finally之前程序就停止运行了，就会不执行，比如线程死亡和CPU被关闭。</p>
</blockquote>
<h3><span id="如何使用try-with-resource">如何使用try-with-resource？</span></h3><blockquote>
<p>是java中的语法糖，用于资源释放，可以让我们更清晰的编写需要关闭的异常</p>
</blockquote>
<h3><span id="使用异常时的注意事项">使用异常时的注意事项？</span></h3><blockquote>
<p>不用将异常定义为静态的，这样会导致栈信息错乱。</p>
<p>在trycatch里，catch中的异常应该从小到大。</p>
</blockquote>
<h3><span id="什么是泛型">什么是泛型？</span></h3><blockquote>
<p>泛型是java中的一种语法糖，可以帮助我们在编译之前就约束参数传递类型，可以增加我们代码的可读性，而且会将一些运行时可能出现的类型转换问题放在编译之前，避免了一些问题。</p>
</blockquote>
<h3><span id="泛型的使用方式">泛型的使用方式？</span></h3><blockquote>
<p>泛型的使用一般是：泛型类、泛型接口和泛型方法</p>
</blockquote>
<h3><span id="泛型的应用场景">泛型的应用场景？</span></h3><blockquote>
<p>当我们需要限制传入参数类型时就可以使用泛型，或者可能会有多种类型时，比如我们在做表现层一致性处理时，我们会创建一个Result统一返回类，其中就可以使用泛型来接收我们的参数，不用object是因为object会导致无法运行子类特有方法。</p>
</blockquote>
<h3><span id="什么是反射">什么是反射？</span></h3><blockquote>
<p>反射赋予了我们在运行时对类进行分析和修改的能力，可以使我们开发更加灵活，但是它会无视我们的访问修饰符，可以暴力反射去获取私有属性或方法，导致不安全，反射的性能会差一点。这是由于在运行期间对类进行修改，需要获取到其中的字段和方法。</p>
</blockquote>
<h3><span id="反射的应用场景">反射的应用场景？</span></h3><blockquote>
<p>在我们的Spring等框架中就到处都是反射，大量使用了动态代理，动态代理的实现也依赖于反射，比如SpringAOP和Spring事务都用到了反射、注解也是用到了反射，通过对类的分析，获取到方法和参数上的注解。</p>
</blockquote>
<h3><span id="什么是注解">什么是注解？</span></h3><blockquote>
<p>注解是一种java的特性，可以当做一种特殊的注释。</p>
</blockquote>
<h3><span id="什么是序列化和反序列化">什么是序列化和反序列化？</span></h3><blockquote>
<p>在我们需要将java对象保存到文件、数据库或者通过网络传输时，就需要用到序列化。序列化是将对象转换为二进制字节流的过程，反序列化是将二进制字节流转换为对象的过程。</p>
</blockquote>
<h3><span id="如果字段不想序列化怎么办">如果字段不想序列化，怎么办？</span></h3><blockquote>
<p>使用关键字transient注解来修饰</p>
</blockquote>
<h3><span id="为什么不使用jdk序列化">为什么不使用jdk序列化？</span></h3><blockquote>
<p>不支持跨语言、性能比较差、存在安全问题。</p>
</blockquote>
<h3><span id="java中传参都是值传递">java中传参都是值传递。</span></h3><h3><span id="什么是语法糖">什么是语法糖？</span></h3><blockquote>
<p>语法糖的存在是为了方便程序员的使用，提供给程序员的一种特殊语法，可以让代码更简洁，更有可读性。jvm并不认识语法糖，所以需要编译器解糖。</p>
</blockquote>
<h3><span id="语法糖switch支持string">语法糖：switch支持string</span></h3><blockquote>
<p>switch支持基本数据类型byte、short、int、char，char是通过ASCII比较的。支持string比较的原因是因为hashcode和equals</p>
</blockquote>
<h3><span id="语法糖泛型">语法糖：泛型</span></h3><blockquote>
<p>泛型是java之后的一种特性，可以通过指定参数类型来限制我们的参数传递，使代码更具有可读性。在编译阶段会被擦除解糖，虚拟机中是没有泛型的。</p>
</blockquote>
<h3><span id="语法糖自动装箱拆箱">语法糖：自动装箱拆箱。</span></h3><blockquote>
<p>基本类型和包装类之间相互转换的过程，底层是valueof方法和intvalue方法。</p>
</blockquote>
<h3><span id="语法糖可变长参数">语法糖：可变长参数。</span></h3><blockquote>
<p>底层是数组。</p>
</blockquote>
<h3><span id="语法糖for-each-增强for">语法糖：for-each、增强for</span></h3><blockquote>
<p>底层是for循环和迭代器</p>
</blockquote>
<h3><span id="语法糖lambda表达式">语法糖：Lambda表达式。</span></h3><h3><span id="语法糖try-with-resource">语法糖：try-with-resource</span></h3><h3><span id="stream流常见方法">Stream流常见方法？</span></h3><blockquote>
<p>中间操作</p>
<p>filter()筛选符合条件的</p>
<p>map()进行转换</p>
<p>distinct()去重</p>
<p>sorted()排序</p>
<p>limited()限制</p>
<p>skip()跳过</p>
<p>flatMap()转换</p>
<p>终结操作</p>
<p>forEach</p>
<p>count</p>
<p>max</p>
<p>min</p>
<p>collect</p>
<p>anymatch/nonematch/allmatch</p>
<p>findany、findFirst</p>
<p>reduce</p>
</blockquote>
<h3><span id="说一下hashmap是怎么解决hash冲突的">说一下HashMap是怎么解决Hash冲突的？</span></h3><blockquote>
<p>拉链法和红黑树的方式解决hash冲突，进行hash比较，与运算获得索引位置，如果有元素就遍历链表或红黑树检查equals是否相等，相等则更新结点，不相等则插入链表尾部或红黑树中。</p>
</blockquote>
<h3><span id="说一下对受检查异常和非受检查异常的理解">说一下对受检查异常和非受检查异常的理解？</span></h3><blockquote>
<p>在java中异常体系都继承自Throwable类，又分为Error和Exception，Error是虚拟机无法处理的错误，比如OOM等jvm层面的问题，这是非受检异常，另外的话Exception中又分为RuntimeException和编译时异常，运行时异常和Error都是不受检查的异常，比如类型转换异常，数组越界，空指针异常等，受检异常包括IO异常、SQL异常和ClassNotFound异常等等。</p>
</blockquote>
<h3><span id="说一下jdk动态代理为什么只能代理有接口的类">说一下JDK动态代理为什么只能代理有接口的类？</span></h3><blockquote>
<p>在java中，实现动态代理是需要继承Proxy类的，而在Java中是不支持多继承的，所以只能创建实现了接口的动态代理类，这也是非常符合面向接口编程的思想的，如果想通过继承的方式实现代理的话可以使用CGLIB动态代理。</p>
</blockquote>
<h3><span id="说一下对象的创建过程">说一下对象的创建过程？</span></h3><blockquote>
<p>在java中一个对象的创建可以分为五个步骤，要先去类加载检查，判断类是否被加载过了，如果被加载过了之后进行内存的分配，内存的分配呢又分为空闲列表和指针碰撞两种方式，这是跟内存是否规整有关的，也就是说有没有内存碎片，这取决于垃圾回收器中的垃圾回收方法，另外就是在内存分配期间可能会存在线程安全问题，可以采用CAS+失败重试的方式或者TLAB的方式解决，之后进行初始化零值，对成员变量赋予0值，然后去设置对象头信息，包括GC年龄、锁状态，类信息、hashcode，然后执行init方法进行初始化设置我们需要的一些特定值。</p>
</blockquote>
<h3><span id="new-stringabc创建了几个对象">new String(“abc”)创建了几个对象？</span></h3><blockquote>
<p>会创建两个对象，首先的话，new这个关键字会调用已经加载的String类，然后去堆中分配空间创建一个String对象，然后在初始化阶段发现构造器中传入了一个字符串常量，所以会去指向字符串常量中该对象，如果常量池中没有，则会创建在常量池中创建一个abc对象，如果常量池中存在abc的引用则直接调用即可。</p>
</blockquote>
<h2><span id="集合框架">集合框架</span></h2><h3><span id="java集合概览">Java集合概览？</span></h3><blockquote>
<p>Java中集合分为单列集合和双列集合，是由Collection和Map两个接口派生出来的，Collection接口下面又分为List、Set、Queue，常见的List包括ArrayList、LinkedList，常见的Set包括HashSet、LinkedHashSet、TreeSet，常见的Map包括HashMap、LinkedHashMap、TreeMap。</p>
</blockquote>
<h3><span id="集合api">集合API</span></h3><blockquote>
<p>Collection：</p>
<p>add、remove、size、isEmpty、clear、contains、addAll、removeAll、containsAll</p>
<p>遍历：迭代器遍历、增强for遍历、Lambda表达式</p>
<p>List的Api：有序有索引，所以按索引get和remove和set，并且可以指定索引插入add，indexOf获取第一次出现位置，lastIndexOf获取最后一次出现的位置，subList获取范围内的元素</p>
</blockquote>
<h3><span id="说说list-set-queue-map的区别">说说List、Set、Queue、Map的区别？</span></h3><blockquote>
<p>List、Set、Queue是单列集合，是Collection下的接口，Map是双列集合。</p>
<p>List：有序、可重复、有索引</p>
<p>Set：不可重复</p>
<p>Queue：实现队列，有序可重复</p>
<p>Map：存储键值对，key不可重复，值可重复</p>
</blockquote>
<h3><span id="集合框架底层数据结构">集合框架底层数据结构？</span></h3><blockquote>
<p>Collection</p>
<p>List：</p>
<p>​        ArrayList底层是动态数组</p>
<p>​        LinkedList底层是双向链表</p>
<p>Set：</p>
<p>​        HashSet（无序、唯一）：底层是HashMap，通过数组+链表+红黑树实现的，8之前是数组+链表，采用头插法。</p>
<p>​        LinkedHashSet（有序、唯一）：底层是LinkedHashMap，在HashMAp基础上加了一层双向链表保证有序性</p>
<p>​        TreeSet（不重复、可排序）：底层是TreeMap</p>
<p>Queue：</p>
<p>​        ArrayQueue：底层是数组+双指针</p>
<p>​        LinkedList：底层是双向链表</p>
<p>Map：</p>
<p>​        HashMap：底层是数组+链表+红黑树</p>
<p>​        LinkedHashMap：在数组链表红黑树的基础上加了双向链表保证有序</p>
<p>​        TreeMAp：底层是红黑树</p>
<p>​        HashTable：哈希表，数组+链表</p>
</blockquote>
<h3><span id="hashmap底层原理">HashMap底层原理？</span></h3><blockquote>
<p>在jdk8之前，hashmap底层数据结构是数组加链表，采用的是头插法插入元素，在jdk8之后采用数组+链表+红黑树作为数据结构，使用尾插法插入元素，当链表超过8，数组长度超过64时会转化为红黑树，主要使用的是拉链法来解决hash冲突。</p>
</blockquote>
<h3><span id="linkedhashmap的原理">LinkedHashMap的原理？</span></h3><blockquote>
<p>继承自HashMAp，在HashMap的基础上，增加了一条双向链表来保证有序性。</p>
</blockquote>
<h3><span id="为什么要使用集合">为什么要使用集合？</span></h3><blockquote>
<p>不使用集合的时候我们通常使用数组，与数组相比，集合框架对数据对象的操作更加灵活，提供了多种数据结构来存储对象，而且有很多内置的高效方法。相较于数组，集合的优势在于大小可变、支持泛型、具有灵活的内建算法，总的来说，使用集合提高了数据存储和处理的灵活性，更能满足我们的开发需要</p>
</blockquote>
<h3><span id="怎么选用集合">怎么选用集合？</span></h3><blockquote>
<p>根据我们的业务需求来，如果是存储键值对就选择Map下的接口，不需要保证有序和可排序条件，则使用HashMap最优，需要保证有序则使用LinkedHashMap，保证排序则使用TreeMap，如果是单一的对象则使用Collection下的接口，一般情况下可重复都是选择使用ArrayList的，不可重复选择使用Set。</p>
</blockquote>
<h3><span id="arraylist和array的区别">ArrayList和Array的区别？</span></h3><blockquote>
<p>Array是静态数组，一旦被创建长度就不能发生改变了，ArrayList是动态数组，数组长度可以改变。</p>
<p>Array是数组，ArrayList是集合，比数组要更加灵活，对数据对象的操作更方便高效。</p>
<p>ArrayList支持泛型、Array不支持</p>
<p>Array支持基本数据类型，ArrayList只支持引用类型</p>
</blockquote>
<h3><span id="arraylist和vector的区别">ArrayList和Vector的区别？</span></h3><blockquote>
<p>Vector是List的早期实现，是线程安全的。</p>
</blockquote>
<h3><span id="vector和stack的区别">Vector和Stack的区别？</span></h3><pre><code>&gt; Stack继承自Vector，二者都是线程安全的，Vector是列表，二Stack是后进先出的栈。虽然是线程安全的，但是效率低下，推荐使用juc包下concurrent开头的线程安全类或者使用CopyOnWrite开头的。
</code></pre>
<h3><span id="arraylist可以添加null吗">ArrayList可以添加null吗？</span></h3><pre><code>&gt; ArrayList是可以添加null的，但是会没有意义，也会导致因为疏忽而导致的类型装换问题。
</code></pre>
<h3><span id="arraylist插入和删除的时间复杂度">ArrayList插入和删除的时间复杂度？</span></h3><pre><code>&gt; ArrayList的数据结构类型与我们数据结构中的顺序表，它的插入和删除时分情况的。
&gt;
&gt; 如果插入在头部，则所有元素后移，时间复杂度为On，如果插入在尾部，且不需要扩容，则时间复杂度为O1，如果需要扩容则会先执行On的扩容再执行O1的插入，如果插入在中间位置，则时间复杂度为On
&gt;
&gt; 删除在头部或中间位置，时间复杂度为On，删除在尾部，为O1。
</code></pre>
<h3><span id="linkedlist的插入删除的时间复杂度">LinkedList的插入删除的时间复杂度？</span></h3><pre><code>&gt; 头尾插入和删除的时间复杂度都是O1，指定位置删除需要先遍历到元素再删除，时间复杂度为On
</code></pre>
<h3><span id="linkedlist为什么不实现randomaccess接口">LinkedList为什么不实现RandomAccess接口？</span></h3><pre><code>&gt; RandomAccess接口只是一个标记接口，实现了这个接口表示可以进行随机访问，ArrayList底层是数组，天然支持随机访问，LinkedList底层是链表，只能通过遍历的方式去访问，不能实现随机访问。
</code></pre>
<h3><span id="arraylist和linkedlist的区别">ArrayList和LinkedList的区别？</span></h3><pre><code>&gt; 一般情况下都是使用ArrayList的，即便是LinkedList的作者也不推荐使用LinkedList。
&gt;
&gt; ArrayList底层是数组，LinkedList底层是双向链表，ArrayList和LinKedList在执行插入和删除时时间复杂度不同，ArrayList在头部插入和删除时间复杂度为On，在尾部插入如果不需要扩容则时间复杂度为O1，需要扩容则时间复杂度为On，在尾部删除时间复杂度为O1，在中间位置插入删除时间复杂度为On，LinkedList在头部和尾部插入删除时间复杂度为O1，在中间位置为On。
&gt;
&gt; ArrayList支持快速随机访问，LinkedList不支持快速随机访问，只能通过遍历方式访问。
&gt;
&gt; ArrayList的内存浪费主要是在尾部预留空间，LinkedList的内存浪费主要是在头尾节点。
&gt;
&gt; 一般是不要LinkedList的，ArrayList的性能更好，占用空间也更少，LinkedList在插入删除时理论上性能更好，但是要进行On的查询找到位置。
</code></pre>
<h3><span id="comparable和comparator的区别">Comparable和Comparator的区别</span></h3><pre><code>&gt; 两个都是用来进行比较的接口，一般来说，当我们需要自定义排序时就要使用Compaator比较器了，因为它优先级更高，可以覆盖源码类中的比较方法。
</code></pre>
<h3><span id="set无序和不可重复的含义">Set无序和不可重复的含义？</span></h3><pre><code>&gt; 无序指的是插入和遍历的顺序是无法保证的，不可重复是只不能出现equals比较是相同的元素。
</code></pre>
<h3><span id="比较hashset-linkedhashset-treeset">比较HashSet、LinkedHashSet、TreeSet</span></h3><pre><code>&gt; 三者都是Set下的接口，元素都不可重复。
&gt;
&gt; HashSet底层是HashMap，是无序的
&gt;
&gt; LinkedHashSet底层是LinkedHashSet，多了双向链表，是有序的
&gt;
&gt; TreeSet底层是TreeMap，是可排序的。
</code></pre>
<h3><span id="queue和deuqe的区别">Queue和Deuqe的区别？</span></h3><pre><code>&gt; Queue是单端队列，先进先出。
&gt;
&gt; Deque是双端队列
</code></pre>
<h3><span id="arraydeque和linkedlis的区别">ArrayDeque和LinkedLis的区别？</span></h3><pre><code>&gt; 二者都实现了Deque
&gt;
&gt; ArrayQueue底层是数组加双指针
&gt;
&gt; LinkedList底层是双向链表
</code></pre>
<h3><span id="hashmap和hashtable的区别">HashMap和HashTable的区别？</span></h3><pre><code>&gt; HashMap是线程不安全的，HashTable是线程安全的，但是HashTable的效率是比较低下的，会影响并发度，因为HashTable是给所有方法加synchronized锁，在高并发场景下导致大量线程阻塞和上下文切换，影响性能。HashTable基本被淘汰了，HashMap底层是数组链表红黑树，HashTable底层是数组链表
</code></pre>
<h3><span id="hashmap和hashset">HashMap和HashSet？</span></h3><pre><code>&gt; HashSet就是基于HashMap实现的，大部分方法都是HashMap的方法，HashSet使用成员对象计算hashcode，HashMap使用key计算
</code></pre>
<h3><span id="hashmap和treemap的区别">HashMap和TreeMap的区别？</span></h3><pre><code>&gt; HashMap底层是数组链表红黑树，TreeMap底层是红黑树，TreeMap是可比较的，可以通过比较器对元素排序。
</code></pre>
<h3><span id="hashset如何检查重复">HashSet如何检查重复？</span></h3><pre><code>&gt; 会先计算出对象的哈希码，根据哈希码和对象长度-1进行与运算，得到数组的索引，判断位置是否有元素，没有元素直接插入，有元素的话就用equals判断是否是真的相同，不相同的话就插入在链表的尾部，相同则替换当前元素。
</code></pre>
<h3><span id="hashmap底层实现">HashMap底层实现？</span></h3><pre><code>&gt; HashMap底层是数组链表红黑树，在java1.8之前，底层是数组加链表，而且采用的是头插法插入元素。
&gt;
&gt; 具体流程是，通过扰动函数处理达到的hashcode，与数组长度-1进行与运算达到元素在数组中的索引位置，如果位置不存在元素则直接插入，如果存在元素，则equals进一步判断元素是否真的相同，相同则直接覆盖，不同则通过拉链法放到链表的尾部。
&gt;
&gt; 在jdk1.8之后，数据结构发生了变化，实现也有所不同，在插入时采用的是尾插法，而且当链表长度超过8，数组长度超过64时会将链表转换为红黑树来提高查找速度。
</code></pre>
<h3><span id="hashmap的长度为什么是2的幂次方">HashMap的长度为什么是2的幂次方？</span></h3><pre><code>&gt; 因为在计算元素在数组中对应的位置时，会进行hashcode和数组长度-1 的与运算，只有是2的幂次方时，取与才等于与运算的值，采用与运算能提高速度。
</code></pre>
<h3><span id="hashmap多线程死循环问题">HashMap多线程死循环问题？</span></h3><pre><code>&gt; 这种情况发生在多个线程同时需要扩容时，由于是头插法进行插入链表，所以会导致节点位置有问题，产生循环死链的情况，导致陷入死循环。
&gt;
&gt; 1.8之后采用尾插法解决循环死链的问题。
</code></pre>
<h3><span id="hashmap线程不安全问题">HashMap线程不安全问题？</span></h3><pre><code>&gt; 表现在两方面，一方面是1.7之前头插法导致循环死链，另一种是修改丢失，由于HashMap是线程不安全的，所以当同时进行put操作时，两个线程都发现对应位置没有元素直接插入，就会导致有一个元素插入被覆盖。相关问题还有很多，比如size不正确。
</code></pre>
<h3><span id="hashmap的遍历">HashMap的遍历？</span></h3><pre><code>&gt; 大致分为迭代器遍历，Foreach增强for遍历，Lamdba表达式遍历，Stream流遍历。
&gt;
&gt; 获取EntrySet进行
&gt;
&gt; 获取KeySet
&gt;
&gt; 使用Foreach
</code></pre>
<h3><span id="arraylist扩容机制">ArrayList扩容机制</span></h3><blockquote>
<p>ArrayList底层是动态数组，有transient修饰，表示不会被序列化，初始为10，扩容为1.5倍</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//大概流程，执行add方法，其中有ensureCapacityInternal方法，将size+1传入，如果起始是空数组，则最小扩容量是10和minCapacity的最大值，然后执行ensureExplicCapacity，判断是否需要扩容，如果最小扩容长度大于数组长度，则要执行grow，否则是不需要执行的，返回到add方法，直接进行数组赋值，如果要扩容则进入grow方法扩容1.5倍，如果扩容后依然小于最小扩容长度，则将新数组长度设置为最小扩容长度，然后进行copyof方法进行数组复制。</span></span><br><span class="line"><span class="comment">//手写一下源码吧</span></span><br><span class="line">ArrayList()&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData=空数组</span><br><span class="line">&#125;</span><br><span class="line">ArrayList(<span class="keyword">int</span> s)&#123;</span><br><span class="line">    <span class="keyword">if</span>(s&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData=<span class="keyword">new</span> Object[s];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData=空数组</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        异常</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">add(E e)&#123;</span><br><span class="line">    ensureCapacityInternal(size+<span class="number">1</span>);</span><br><span class="line">    elementData[size++]=e;</span><br><span class="line">&#125;</span><br><span class="line">ensureCapacity(<span class="keyword">int</span> minCapacity)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.elementData==空数组)&#123;</span><br><span class="line">        minCapacity=Math.max(<span class="number">10</span>,minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureExplicCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line">ensureExplicCapacity(<span class="keyword">int</span> minCapacity)&#123;</span><br><span class="line">    <span class="keyword">if</span>(minCapacity-<span class="keyword">this</span>.elementData.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">grow(<span class="keyword">int</span> minCapacity)&#123;</span><br><span class="line">    <span class="keyword">int</span> OldCapacity=elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity=OldCapacity+OldCapacity&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(newCapacity-minCapacity&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        newCapacity=minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(newCapaCity-MAX_SIZE&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        newCapaCity=hugeCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    elementData=Arrays.copyOf(elementData,newCapaCity)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="hashmap源码分析">HashMap源码分析</span></h3><h4><span id="hashmap数据结构">HashMap数据结构</span></h4><blockquote>
<p>在jdk1.8之前，HashMap采用数组加链表作为数据结构，数组是主题，链表用来解决hash冲突，hash冲突时链表使用头插法插入新节点。</p>
<p>在jdk1.8之后，HashMap采用数组链表红黑树作为数据结构，采用的是尾插法，而且当链表长度超过8并且数组长度超过64时会转换为红黑树来提高查找速度。</p>
</blockquote>
<h4><span id="put">put</span></h4><blockquote>
<p>调用put方法是调用的putVal方法</p>
<p>执行流程是：</p>
<p>通过hash扰动算法将hash扰动转换和数组长度减一进行与运算得到数组索引位置，判断该位置是否有值，如果为空，则直接插入一个node节点，如果不为空，则判断第一个元素是否相同，相同则替换，不同则判断是不是红黑树结点，是的话到红黑树中遍历判断，不是则到链表中遍历判断是否有相同的key，没有则插入链表尾部。</p>
</blockquote>
<h4><span id="resize">resize</span></h4><p>resize是扩容和方法，HashMap的初始容量为16，是否需要扩容则看加载因子，如果数组长度超过阈值或者链表长度超过8，就会进行扩容，以2的倍数进行扩容，然后为了解决hash碰撞，则会进行一次rehash计算，将对象均匀的分布在数组上，同样适用拉链法解决hash冲突，当链表长度超过8并且数组长度超过64时转换为红黑树。</p>
<h3><span id="concurrenthashmap">ConcurrentHashMap</span></h3><blockquote>
<p>ConcurrentHashMap是对HashMap并发安全的实现。</p>
<p>在jdk1.7中，ConcurrentHashMap是由segment数组和entry数组组成的，每一个segment都是一个ReentrantLock，当多个线程进行put操作的时候，会经过hash和segment的 数组长度-1进行与运算，计算出segment的索引位置，如果不为null则使用，为null则CAS创建新的segment，定位到segment后trylock获取锁，获取到锁的对象进入到entry数组中进行put操作，也是得到索引位置，然后尝试put，获取不到锁的对象进行非阻塞的创建entry对象，直到获取到锁然后进行put操作，具体的put逻辑是和HashMap比较类似。</p>
<p>在jdk1.8中是采用对node结点CAS和synchronized加锁的方式来实现的，不再使用segment，这样的话锁粒度会更小，而且，引入了红黑树，可以减少我们检索node的速度。</p>
</blockquote>
<h3><span id="concurrenthashmap的get需要加锁吗">ConcurrentHashMap的get需要加锁吗？</span></h3><blockquote>
<p>不需要的，因为node的value和下一个结点都被volatile修饰了，一个线程对它进行修改时，对其他线程是可见的，所以是不需要加锁的。</p>
</blockquote>
<h3><span id="concurrenthashmap的key和value的值为什么不能为null">ConcurrentHashMap的key和value的值为什么不能为null？</span></h3><blockquote>
<p>key不为null是因为设计者设计的时候就设置了不为null，属于是规范问题。</p>
<p>value不为null，是因为value为空的时候在多线程情况下比较复杂，比如一个线程使用get获取到的是null，不能确定是key不存在还是value为null，需要执行containsKey，此时如果有其他线程进行了新增或删除的时候，会影响到containsKey的结果，而HashMap可以为null是因为可以执行containsKey判断是否有这个key。</p>
</blockquote>
<h3><span id="concurrenthashmap的迭代器是强一致性还是弱一致性的">ConcurrentHashMap的迭代器是强一致性还是弱一致性的？</span></h3><blockquote>
<p>弱一致性的，如果修改发生在迭代器之前，是不会改变迭代结果，如果发生在改变之后需要改变迭代结果。</p>
</blockquote>
<h3><span id="jdk7和8中concurrenthashmap的区别">jdk7和8中ConcurrentHashMap的区别？</span></h3><blockquote>
<p>7中的数据结构是segment数组和entry数组，8中使用的是数组链表红黑树。</p>
<p>7中将Map分为多个段，采用ReentrantLock分段加锁的方式来实现线程安全，8中是对node结点加锁，通过CAS和synchronized的方式保证的并发安全，锁的粒度更小，而且有红黑树，当链表长度超过8并且数组长度超过64会转换为红黑树，搜索时间复杂度是logn，保证了查找效率。</p>
</blockquote>
<h3><span id="为什么jdk8之后使用synchronized代替了reentrantlock">为什么jdk8之后使用synchronized代替了ReentrantLock？</span></h3><blockquote>
<p>一方面是因为synchronized实现了大量的优化，比如轻量级锁和偏向锁。另一方面，synchronized是对node加锁，锁的粒度更低，增高了并发度，还有就是如果jdk8继续使用ReentrantLock的话，由于是对结点加锁，可能会导致大量ReentrantLock对象的产生。</p>
</blockquote>
<h3><span id="currenthashmap的并发度是怎么设计的">CurrentHashMap的并发度是怎么设计的？</span></h3><blockquote>
<p>所谓的并发度就是可以被多少个线程获得锁，在jdk中，是对segment加锁的，所以实际上segment的数组长度就是并发度，是不小于初始参数的2次幂来设置的，具体大小的选取要自己考虑，太小会导致锁竞争，太大则会导致资源的浪费，并且要有多个ReentrantLock对象。在jdk8中摒弃了segment，是对结点加synchronized锁，所以并发度是数组长度。</p>
</blockquote>
<h3><span id="concurrenthashmap和hashtable的效率">ConcurrentHashMap和HashTable的效率？</span></h3><blockquote>
<p>ConcurrentHashMap锁的粒度更小，是对segment分段加锁或者对node结点加锁，而HashTable是整体加锁，锁粒度过大，影响性能和效率。</p>
</blockquote>
<h3><span id="实现线程安全的map的方式">实现线程安全的Map的方式？</span></h3><blockquote>
<ul>
<li>使用JUC下的Map，比如CurrentHashMap。</li>
<li>使用HashTable，性能差。</li>
<li>使用Collections中的方法包装一个Map为线程安全的，性能差。</li>
</ul>
</blockquote>
<h3><span id="copyonwritearraylist">CopyOnWriteArrayList</span></h3><blockquote>
<p>CopyOnWriteArrayList是对ArrayList的并发安全的实现，使用写时复制的技术来保证线程安全，是读写分离的，读操作不需要加锁，写操作需要加锁，而且是拷贝一份数组，在新的数组上进行修改，不会影响原数组的读写。适合于读多写少的场景，缺点就是会拷贝数组，消耗内存，如果数组太大就会导致minor gc和full gc。应该在存储量比较确定的时候使用，否则无法保证存储量，会导致每次修改都导致拷贝数组，代价较高。</p>
</blockquote>
<p>​    </p>
<h2><span id="jvm">JVM</span></h2><h3><span id="什么是java跨平台性">什么是Java跨平台性？</span></h3><blockquote>
<p>Java是平台无关的，在java程序运行前，会经过编译器生成.class字节码文件，字节码文件不面向任何平台只针对jvm，jvm将字节码文件转化为机器码并运行，也就是说只要我们在不同的平台上安装响应的JVM，就可以执行我们的字节码文件，这就保证了java程序的一个跨平台性。</p>
</blockquote>
<h3><span id="什么是jvm语言无关性">什么是JVM语言无关性？</span></h3><blockquote>
<p>JVM是语言无关的，只理解class文件，所以其他语言（例如Kotlin）想要使用jvm运行程序，就可以编译为字节码文件去让jvm执行。</p>
</blockquote>
<h3><span id="什么是jvm的解释执行">什么是JVM的解释执行？</span></h3><blockquote>
<p>jvm字节码解释器对生成的class字节码文件进行逐行解释，转换为机器码进行执行，就是解释执行。</p>
</blockquote>
<h3><span id="什么是jit即时编译">什么是JIT即时编译？</span></h3><blockquote>
<p>在jvm中，将字节码转换为机器码有两种方式，一种是即时编译，一种是解释器解释执行，在jvm中，如果一些热点代码我们频繁去解释执行的话，会执行效率较低，所以他会判断是否是热点代码，如果是热点代码则通过即时编译去整体编译为机器码保存下来，否则走字节码解释器逐行解释执行。</p>
</blockquote>
<h3><span id="对象一定会创建在堆中吗">对象一定会创建在堆中吗？</span></h3><blockquote>
<p>对象不一定会创建在堆中，在jvm中，有即时编译和解释器解释执行两种转换为机器码的方式，当我们的代码被认定为是热点代码时就会走即时编译然后去逃逸分析看看是否在方法外有对象的引用，如果没有的话再看有没有设置标量替换，如果设置了标量替换，则不再堆中创建对象，而是在栈中去创建若干个成员变量。</p>
<p>标量替换：不能再被拆解的对象被定为标量，如基本数据类型，可以被拆解为一个个成员变量的叫聚合量，在即时编译时被判断为没有逃逸出方法，我们就可以进行标量替换，对象不在堆中产生。</p>
</blockquote>
<h3><span id="讲讲jvm10种垃圾回收器">讲讲JVM10种垃圾回收器？</span></h3><ul>
<li>Serial、SerialOld：早期久远的垃圾回收器，是单线程串行的，会stw，Serial回收新生代，使用的是复制算法，Serial回收老年代，使用标记-整理算法。</li>
<li>Parallel、ParallelOld，与多线程的Serial，是多线程并行回收的，会stw，多个回收线程并行回收，Parallel回收新生代，使用复制算法，Parallel回收老年代，使用标记-整理算法，java8默认。</li>
<li>ParNew、CMS，ParNew和CMS组合使用，ParNew回收新生代，和Parallel回收器几乎一样，但是Parallel回收器关注与吞吐量，可以自适应调节，将优化交给虚拟机，CMS回收老年代使用标记清除算法，CMS实现了真正意义上的并发回收垃圾，会在初始标记阶段STW，标记GC Roots的直连对象，然后用户线程和回收线程并发执行，并发标记存活对象，之后STW进行重新标记，处理一些漏标问题（很快），之后进行并发清理，CMS的问题就是使用标记清除算法，会导致有内存碎片，而且在并发标记和并发清理阶段如果有新的对象进入到老年代，就要去执行Serial进行全局清理，在并发清理时，可能会有新的对象，此时变成浮动垃圾，交给下一次GC进行清理。</li>
<li>G1垃圾回收器，也是并发的垃圾回收器，适用于多核和堆比较大时，将堆划分成一个一个的单元，弱化了新时代和老年代的概念，各个区是不连续的，在垃圾回收时，依然会经历初始标记、并发标记和最终标记，和CMS比较类似，但是它是筛选清理的，即在后台会维护一个优先列表，根据我们设定的垃圾回收时间，优先回收回收价值最大的单元，宏观上是使用复制算法，微观上是使用标记整理算法，java9之后默认。</li>
<li>ZGC作用于堆空间比较大的时候，而且STW时间几乎感受不到，有了更多的业务适应。</li>
<li>Shenandoah</li>
<li>Eplish</li>
</ul>
<h3><span id="什么是stw">什么是STW？</span></h3><blockquote>
<p>STW，即Stop The World，就是在我们进行GC垃圾回收时，我们需要对用户线程进行一个暂停挂起，这个操作叫做STW，即暂停整个世界。</p>
<p>如果GC时没有STW操作会怎样？如果在GC时，我们没有去暂停用户线程的话，用户线程会依旧持续向堆中存放对象，会导致内存管理的不一致性和错误。会导致漏标和浮动垃圾的问题。</p>
</blockquote>
<h3><span id="什么是可达性分析算法和引用计数法">什么是可达性分析算法和引用计数法？</span></h3><blockquote>
<p>可达性分析算法和引用计数算法是判断是否是垃圾对象的方法，引用计数法实现比较简单，只需要在对象中设置计数器来表示被引用了几次，当为0时即为垃圾对象，但是这种效率较低，而且不能解决循环引用的问题，可达性分析的话是从GC Roots（类变量引用、常量引用、静态属性引用）开始向下搜索创建引用链，如果引用到则是可达的，即不是垃圾对象，如果没有的话就是垃圾对象。</p>
</blockquote>
<h3><span id="讲一讲垃圾回收算法复制算法标记-清除算法-标记-整理算法">讲一讲垃圾回收算法？（复制算法，标记-清除算法、标记-整理算法）</span></h3><blockquote>
<p>复制算法、标记-清除算法、标记管理算法是jvm中的垃圾回收算法。</p>
<p>标记清除算法分为标记阶段和清除阶段，标记阶段将不用被回收的对象标记出来并且记录在对象头中，然后在清理阶段去清理需要回收的内存空间，原理比较简单，但是会有内存碎片，并且执行效率不高。</p>
<p>复制算法则是指的是将内存分为两块，每判断一个对象是不需回收时，就将它复制到空白的内存区域，然后回收之前的那部分区域，这种算法执行效率比较高，而且避免了内存碎片，但是不适合与存活对象较多的情况，如老年代，也会导致有内存利用率降低。</p>
<p>标记整理算法指的是，在一个内存区域内，将可用的对象整理到内存的一边，回收边界外的对象，这种算法效率比较低，但是解决了碎片化问题，适用于短时间内不会频繁GC的情况，比如老年代。</p>
</blockquote>
<h3><span id="讲讲分代模型">讲讲分代模型？</span></h3><pre><code>- 分代模型根据对象的存活时间来划分为新生代和老年代的一种算法，他的目的是分块选用不同的垃圾回收算法，达到整体垃圾回收的高效性。
- 为什么要分为新生代和老年代？因为在垃圾回收的理念中，认为很多对象是朝生夕死的，这些对象的存活时间较短，但是有些对象存活时间较长，为了提高整体的垃圾回收效率，适配各种垃圾回收算法，所以对堆进行了分区，在新生代中的对象是存活效率比价低的，即存活的对象较少，使用复制算法效率比较高，在老年代，对象存活时间较长，存活率较高，可以使用标记清除或标记整理算法。
</code></pre>
<h3><span id="讲一讲cms垃圾回收器">讲一讲CMS垃圾回收器？</span></h3><pre><code>&gt; CMS垃圾回收器是一种并发并行的垃圾回收，它用于回收老年代，使用的是标记清除算法，它真正意义上实现了并发清理，降低了STW的时间，用户的体验会更好，它在初始标记阶段STW，多个垃圾回收线程并行初始标记，只标记GCroots下面的直接引用对象，速度很快，这个STW的时间很短，然后在并发标记阶段标记这些直接引用下面的对象，这个过程用户线程和回收线程同时进行，所以可能会有漏标问题，然后在重新标记阶段STW，解决一下漏标，之后进行并发清理操作。整个过程STW的时间较少。
&gt;
&gt; 但是CMS是并行的垃圾回收，所以会对CPU比较敏感，在并发标记或清理时如果有新的对象进入到老年代，将老年代填满的话，就会去使用Serial垃圾收集器进行收集，二期在并发清理时，会有新的垃圾产生，导致浮动垃圾的出现，交由下一次GC清理。
</code></pre>
<h3><span id="讲一下g1垃圾回收器">讲一下G1垃圾回收器？</span></h3><pre><code>G1即GarbageFirst垃圾回收器，意思就是垃圾优先的，它会在后台产生一个优先列表，优先执行回收价值最大的内存，G1回收器的话还可以指定我们垃圾回收的时间，达到STW可控的目的。它对内存进行了空间整合和划分，将堆内存空间划分为一个个的Region单元，依然也保留了新生代和老年代的概念，它也同样是并行和并行的，在标记阶段并行进行标记，也可以和用户线程同时进行，减少了SWT的时间的同时，还挺高了系统的吞吐量，适合于多核的处理器和大容量内存的机器。
</code></pre>
<h3><span id="三色标记法">三色标记法？</span></h3><blockquote>
<p>起始都是白色的，表示没有被垃圾回收器访问过，初始标记阶段会将直接连接的对象变成灰色，但是还有引用没有被扫描，黑色表示已经扫描完成，所有引用都进行了标记。但是会出现漏标和多标的情况</p>
</blockquote>
<h3><span id="java内存区域有哪些堆-方法区-虚拟机栈-本地方法栈栈帧局部变量表-操作数栈-动态链接和方法出口-程序计数器">Java内存区域有哪些？（堆、方法区、虚拟机栈、本地方法栈（栈帧（局部变量表、操作数栈、动态链接和方法出口））、程序计数器）</span></h3><pre><code>&gt; Java的内存区域分为堆、方法区、虚拟机栈、本地方法栈和程序计数器，堆和方法区是线程共享的，虚拟机栈、本地方法栈和程序计数器是线程独享的，在栈中，每一次方法的调用都会生成栈帧压入栈中，方法结束时出栈，栈帧是由局部变量表、操作数栈、动态链接和方法出口构成的，局部变量表存放一些局部变量，操作数栈用于记录计算过程中产生的临时变量和中间结果，动态链接是在一个方法中需要调用另一个方法时，将符号引用解析为直接引用，得到方法在内存中的指针或偏移量。方法出口指的是，方法执行结束后应该继续执行哪段代码的记录。本地方法栈是调用本地方法时产生的空间，也是会生成栈帧压栈和出栈，也会发生SOF和OOM的问题，当线程的方法层级过深时，会发生栈溢出，当线程过多，内存不足以创建新线程时会导致OOM内存溢出。程序计数器是内存区域的一小块内存空间，记录了下一条指令的位置，字节码执行引擎会根据程序计数器选取下一条要执行的指令，程序计数器保证了我们程序的流程控制和多线程时的轮转恢复。
</code></pre>
<h3><span id="什么是堆内存堆内存包含哪些部分">什么是堆内存？堆内存包含哪些部分？</span></h3><pre><code>&gt; 堆内存是内存区域中最大的一块，用于存放实例化的对象，是垃圾回收器管理的重要区域，根据分代模型思想，根据对象的存活时间将堆划分为新生代和老年代，新生代又分为Eden区和survivor区。
</code></pre>
<h3><span id="什么是内存溢出oom">什么是内存溢出（OOM）？</span></h3><pre><code>&gt; OOM，即outofmemory，造成OOM的原因有很多，一般是由三种原因导致的，一次性创建的对象太多，比如我们做业务时没有分页，而是全查，当数据量很大时，创建对象过多就会导致OOM，也可能是资源未释放导致的内存资源耗尽，即应该释放的资源未释放导致老年代占满溢出，第三种就是我们的本身内存是不够的，就不够我们去创建大对象。
&gt;
&gt; 排查OOM可以通过jmap -heap 来查看我们堆的参数，包括Eden区的大小以及新生代和老年代的分配情况等，判断会不会是我们本身设置的堆内存不够导致的OOM。也可以使用dump去定位我们的OOM，提前设置-XX:+HeapDumpOutOfMemoryError
&gt;
&gt; -XX:HeapDumpPath,然后使用JavaVisual去载入dump文件去快速定位OOM的位置
</code></pre>
<h3><span id="什么是内存泄露memory-leak">什么是内存泄露（Memory Leak）？</span></h3><pre><code>&gt; 内存泄露即因为疏忽或者错误导致程序未能释放已经不再使用的资源，其实就是内存动态申请的内存空间未能释放或者无法释放，内存泄露的叠加会导致我们的内存溢出OOM。
</code></pre>
<h3><span id="对象头包括什么对象头对象自身的运行时数据-类型指针-数组长度-实例数据-对齐填充">对象头包括什么？（对象头（对象自身的运行时数据、类型指针、数组长度）、实例数据、对齐填充）</span></h3><h3><span id="jvm常见参数">JVM常见参数？</span></h3><pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 设置对内存</span><br><span class="line">-Xms### -Xmx### //分别设置初始堆大小和最大堆空间大小</span><br><span class="line"># 指定GC回收器</span><br><span class="line">-XX:+UseG1GC -XX:MaxGCPauseMillions=50//使用GC回收器，指定最大垃圾回收时间</span><br><span class="line"># 并行线程数</span><br><span class="line">-XX:ParallelGCThreads=4 //设置并行线程</span><br><span class="line"># 打印日志</span><br><span class="line">-XX:+PrintGCDetails -XX:+PrintGCDateStamps</span><br><span class="line"># 指定GC日志</span><br><span class="line">-Xloggc:gc.log</span><br><span class="line"># 指定元空间最大值</span><br><span class="line">-XX:MaxMetaspaceSize=2g</span><br><span class="line"># 设置单个线程栈的大小</span><br><span class="line">-Xss1m</span><br><span class="line"># 指定oom时自动Dump</span><br></pre></td></tr></table></figure>
</code></pre>
<h3><span id="如何设置堆空间的最大值">如何设置堆空间的最大值？</span></h3><h3><span id="java8的默认的垃圾回收器">java8的默认的垃圾回收器？</span></h3><pre><code>- Parallel、ParallelOld
</code></pre>
<h3><span id="什么是并行垃圾收集">什么是并行垃圾收集？</span></h3><h3><span id="什么是stw什么是安全点什么是安全区域">什么是STW?什么是安全点？什么是安全区域？</span></h3><h3><span id="cpu过高怎么排查">CPU过高怎么排查？</span></h3><h3><span id="三色标记了解过吗漏标情况怎么解决">三色标记了解过吗？漏标情况怎么解决？</span></h3><h3><span id="讲一讲类加载和类加载器">讲一讲类加载和类加载器？</span></h3><pre><code>&gt; 类的生命周期是从加载到卸载的过程，包括加载、验证、准备、解析、初始化、使用和卸载七个阶段，我们需要使用类加载子系统去从class中加载我们的类去使用，所以要有类加载，类加载分为加载、连接、初始化三个阶段，连接阶段又分为验证、准备和解析，加载阶段主要是将class文件转为二进制字节流，将其中的存储结构转为方法区中运行时的数据结构是，在内存中生成一个代表该类的Class对象，作为访问数据的入口，加载阶段主要是由类加载器来完成的，验证阶段主要是检验我们class二进制字节流中的信息是否是安全的，比如文件格式检验，语法格式检验和符号引用检验，准备阶段用于类变量的内存分配和赋予0值，解析阶段会将符号引用转为直接引用，初始化阶段对类信息进行初始化。
&gt;
&gt; 类加载器用于完成我们类加载阶段中的加载，类加载器分为自定义加载器和引导类加载器，jvm为我们提供了BootStrapClassLoader、ExtClassLoader和AppClassLoader类加载器，每一个类都有加载该类的类加载器，类加载规则是遵循双亲委派模型的，双亲委派机制是指，我们检查类是否被加载时从下往上去检查的，我们加载类的顺序是从上往下的，如果父级加载器无法加载此类，就逐级向下，交给后面的加载器，这样能避免类的重复加载和核心API的篡改。
</code></pre>
<h3><span id="什么是双亲委派机制">什么是双亲委派机制？</span></h3><pre><code>&gt; 自顶向下加载，自底向上判断是否加载。避免类的重复加载和核心api篡改，保证程序的正常运行。
</code></pre>
<h3><span id="g1收集器有哪些特点">G1收集器有哪些特点？</span></h3><pre><code>&gt; 内存整合：G1收集器对内存进行了整合，划分为一个个的Region单元，也保留了分代模型的概念。
&gt;
&gt; 筛选回收：G1收集器它会在后台生成一个优先列表，在垃圾回收时判断出哪个内存的回收价值最大就回收哪个，即和它的名字一样，GarbageFirst，垃圾优先。
&gt;
&gt; 并行并发回收：在初始标记阶段会stw，多个垃圾回收线程并行进行垃圾回收。
&gt;
&gt; 垃圾回收时间可预测，我们可以手动指定垃圾回收的时间。
</code></pre>
<h3><span id="哪些手段排查oom">哪些手段排查OOM？</span></h3><h3><span id="java程序的执行过程">java程序的执行过程</span></h3><blockquote>
<p>Java程序在运行前会先经过编译器编译成为字节码文件，然后交给类加载器加载到内存，之后通过jvm字节码执行引擎将字节码逐行解释为机器码到CPU进行运行。</p>
<p>经过编译器编译为字节码文件</p>
<p>通过类加载器将字节码加载到内存中</p>
<p>jvm对字节码进行解释执行</p>
<p>类加载过程：加载-》连接-》初始化-》使用</p>
<p>连接又分为：验证、准备、解析</p>
<p>编译过程包括：</p>
<p>初始化插入式注解处理器</p>
<p>词法语法分析，填充符号表</p>
<p>处理注解</p>
<p>解语法糖</p>
</blockquote>
<h4><span id="类加载过程">类加载过程</span></h4><blockquote>
<p>类生命周期：加载、验证、准备、解析、初始化、使用、卸载</p>
<p>加载过程包括：加载、链接、初始化，链接阶段分为验证、准备、解析。</p>
<p>加载是获取到类的二进制字节流，将字节流代表的静态存储结构转化为方法区的运行时数据结构，生成Class对象放在堆中，作为方法区这些数据的访问入口。</p>
<p>验证阶段：验证字节流的安全性和合法性</p>
<p>准备阶段：为static修饰的变量分配内存空间</p>
<p>解析阶段：将符号引用解析为直接引用。</p>
</blockquote>
<h3><span id="对象的创建过程">对象的创建过程</span></h3><blockquote>
<p>先检测类是否被加载，确定类已经被加载过之后开始在分配内存，内存的分配有两种方式，一种是指针碰撞，一种是空闲列表，具体怎么分配要看是否有内存碎片，也就是看使用的什么垃圾清理算法，内存分配时的并发问题需要使用CAS+失败重试的方式解决，或者通过TLAB为每一个线程预留堆空间的方式解决。之后进行初始化零值，将成员变量赋予默认值，之后设置对象头信息，应该包括GC年龄、hash码、元数据指针、锁标志信息，然后执行init初始化方法</p>
</blockquote>
<h2><span id="并发编程">并发编程</span></h2><h3><span id="什么是进程和线程">什么是进程和线程？</span></h3><blockquote>
<p>进程可以理解为是程序的一次执行过程，是程序运行的基本单位，程序的一次运行就是进程从创建到消亡的过程，线程的话是进程中划分出的更小的执行单位，一个进程可以产生多个线程，线程的创建和调度的开销较小，又被称为轻量级进程。</p>
</blockquote>
<h3><span id="描述进程和线程的关系-区别和优缺点">描述进程和线程的关系、区别和优缺点？</span></h3><blockquote>
<p>一个进程可以有多个线程，多个线程共享进程的方法区和堆，每个线程都独有自己的程序计数器、虚拟机栈、本地方法栈。他们最大的不同是进程是独立的，线程是可能会相互影响的，线程的开销较小，但不利于对资源的管理和保护，进程的创建和调度开销较大，但有利于资源管理和保护。</p>
</blockquote>
<h3><span id="为什么程序计数器是私有的">为什么程序计数器是私有的？</span></h3><blockquote>
<p>程序计数器是线程所私有的，是较小的一块内存区域，它记录了下一条指令的位置，字节码执行引擎通过程序计数器来选取下一条要执行的指令，达到流程控制的效果，在多线程上下文切换时，可以起到轮转恢复运行的效果，所以程序计数器私有的目的是为了使线程发生轮转时可以恢复到正确位置。</p>
</blockquote>
<h3><span id="虚拟机栈和本地方法栈为什么是私有的">虚拟机栈和本地方法栈为什么是私有的？</span></h3><blockquote>
<p>我们每次调用方法时，都会产生栈帧压入栈中，java方法压入虚拟机栈，本地方法压入本地方法栈，栈帧内部是由局部变量表、动态链接、方法出口、操作数栈组成的，私有的目的是为了防止其他线程读取到当前线程的局部变量。</p>
</blockquote>
<h3><span id="一句话了解方法区和堆">一句话了解方法区和堆？</span></h3><blockquote>
<p>堆和方法区都是线程共享的，堆是内存区域中最大的一块，基本上所有的对象实例都存放在堆上，方法区主要用于存放已经被加载的类信息、常量静态变量和一些JIT即时编译产生的代码等数据。</p>
</blockquote>
<h3><span id="并发和并行的区别">并发和并行的区别？</span></h3><blockquote>
<p>并发指的是在多个任务在同一时间间隔内执行，宏观上是同时发生，微观上是交替执行。</p>
<p>并行指的是多个任务在同一时刻执行，需要依赖于CPU核心数。</p>
</blockquote>
<h3><span id="同步和异步的区别">同步和异步的区别？</span></h3><blockquote>
<p>同步指的是需要等待结果才会继续往下执行。</p>
<p>异步是无需等待返回结果。</p>
</blockquote>
<h3><span id="为什么要使用多线程">为什么要使用多线程？</span></h3><blockquote>
<p>从计算机层面来看的话，线程是轻量级的进程，线程的创建和调度开销较小，多线程时并发编程的基础，利用好线程可以帮我们大大提高系统的并发能力和性能，在单核时代使用多线程可以提高系统资源的整体利用率，多核时代可以充分利用CPU，大大提高性能。</p>
</blockquote>
<h3><span id="使用多线程可能会有什么问题">使用多线程可能会有什么问题？</span></h3><blockquote>
<p>在多个线程同时被阻塞，等待某一资源的释放时，会导致死锁，程序无法继续运行，当创建线程过多时，可能会导致OOM内存溢出问题，多线程下要进行线程的轮转，所以共享资源可能会有不安全的问题。</p>
</blockquote>
<h3><span id="什么是线程安全和线程不安全">什么是线程安全和线程不安全？</span></h3><blockquote>
<p>线程安全是指在多线程环境下，对于同一个共享资源，无论线程有多少，都不会影响其一致性和完整性。</p>
<p>线程不安全是指多线程环境下，对于同一个共享资源，无法保证其一致性和完整性，导致数据丢失等问题。</p>
</blockquote>
<h3><span id="说说线程的生命周期和状态">说说线程的生命周期和状态？</span></h3><blockquote>
<p>传统的五个生命周期是指：初始状态、就绪态、运行态、阻塞态和结束态。</p>
</blockquote>
<pre><code>&gt; Java中线程的生命周期是六个：New、Runnable、blocked、waiting、time_waiting、结束态。
</code></pre>
<blockquote>
<p>线程被创建时是初始态，在调用start时会进入到就绪态，此时可以被分配时间片进行运行，当获取不到锁时进入到blocked阻塞态，当调用join、wait、park时会进入到waiting等待状态，调用sleep(s),wait(s)时会进入超时等待状态，线程运行完毕进入终止态。</p>
</blockquote>
<h3><span id="为什么java的线程不区分运行态和就绪态">为什么Java的线程不区分运行态和就绪态？</span></h3><blockquote>
<p>因为现在的时分操作系统架构中通过时间分片抢占式的方式进行轮转调度，时间片是比较小的，所以线程的切换时很快的，区分两种状态没有意义，所以都归为runnable运行态。</p>
</blockquote>
<h3><span id="什么是线程上下文切换">什么是线程上下文切换？</span></h3><blockquote>
<p>线程都有自己的运行状态和私有区域，比如程序计数器和虚拟机栈，当发生线程轮转时就会保存当前线程上下文，留着等待恢复，并且加载下一个上下文。</p>
<p>上下文切换会占用CPU和内存，频繁的上下文切换会造成整体效率变低。</p>
<p>当调用sleep、wait、park等方法时，会让出CPU，会发生上下文切换，当时间片用完时也会发生上下文切换，当GC垃圾回收时会STW，也会发生上下文切换。</p>
</blockquote>
<h3><span id="什么是死锁怎么避免死锁">什么是死锁？怎么避免死锁</span></h3><blockquote>
<p>当多个线程同时被阻塞，相互等待一个或多个资源的释放时，线程被无限阻塞，这就是死锁现象。</p>
<p>死锁的必要条件：</p>
<ul>
<li>互斥条件：该资源只能被一个线程占有</li>
<li>请求保持条件：线程对已获得的资源保持不放</li>
<li>不剥夺条件：已获得资源不能被其他线程强行剥夺</li>
<li>循环等待条件：若干线程之间形成了循环等待的资源关系。</li>
</ul>
<p>避免死锁需要破坏死锁的必要条件，我们可以在线程获取不到资源时进行释放资源破坏请求保持条件，改变循环等待的关系来破坏循环等待条件。</p>
</blockquote>
<h3><span id="sleep和wait的区别">sleep和wait的区别？</span></h3><blockquote>
<p>sleep 是Thread类中的方法，wait是Object的方法，sleep是暂停线程运行，不会释放锁，wait会释放锁。wait必须结合对象锁来使用。</p>
</blockquote>
<h3><span id="为什么wait不定义在thread中">为什么wait不定义在Thread中？</span></h3><blockquote>
<p>我们知道，在加synchronized锁时，会与一个操作系统中的monitor相关联，monitor中owner记录当前线程，当调用wait方法时，会进入到waitset中，并且释放当前锁，自然是要对对象锁进行操作，而非线程。</p>
<p>为什么sleep定义在Thread中？</p>
<p>sleep是暂停当前线程，和对象无关，也不需要加对象锁。</p>
</blockquote>
<h3><span id="可以直接调用run方法吗">可以直接调用run方法吗？</span></h3><blockquote>
<p>我们应知道线程的执行流程，在调用start方法时会让线程进入就绪态可以获得时间片运行，start是一个本地方法，如果获取到时间片就会自动执行run方法，这才是真正的开启了线程，我们直接调用run方法只是相当于调用了普通方法，并不是多线程工作。</p>
</blockquote>
<h3><span id="创建线程有哪几种方式">创建线程有哪几种方式？</span></h3><blockquote>
<h3><span id="继承tread类重写run方法">继承Tread类，重写run方法</span></h3><h3><span id="实现runnable接口">实现Runnable接口</span></h3><h3><span id="实现callable接口用futuretask包装callable对象其中也封装了线程的返回值然后交给thread运行">实现Callable接口，用FutureTask包装Callable对象，其中也封装了线程的返回值，然后交给Thread运行。</span></h3><p>使用Runnable和Callable接口创建的线程可以继承其他的类，实现其他接口，比Thread类创建的线程要更具有扩展性，但是就不能使用Thread中的一些方法了。</p>
</blockquote>
<h3><span id="thread的常用方法">Thread的常用方法？</span></h3><blockquote>
<h3><span id="currentthread获取到当前运行的线程">currentThread获取到当前运行的线程。</span></h3><h3><span id="interrupted用于添加打断标记">interrupted()用于添加打断标记</span></h3><h3><span id="sleep暂停当前线程">sleep，暂停当前线程</span></h3><h3><span id="yield让步线程将暂时放弃cpu片">yield，让步线程，将暂时放弃CPU片</span></h3><h3><span id="getid">getid</span></h3><h3><span id="getname">getname</span></h3><h3><span id="getprioritysetpriority设置优先级">getpriority，setpriority设置优先级</span></h3><h3><span id="isdaemon-setdaemon设置是否是守护线程">isDaemon、setDaemon设置是否是守护线程</span></h3><h3><span id="join等待线程运行">join等待线程运行</span></h3></blockquote>
<h3><span id="run和start的区别">run和start的区别？</span></h3><blockquote>
<p>run是线程执行体，里面是线程所需要执行的业务，start是启动线程的方法，start是本地方法，会进入到就绪态，真正获取到时间片后会自动调用run方法，这才是真正开启了线程，直接调用run方法并不会被当做执行体，只是相当于普通方法，没有开启多线程。</p>
<p>start是本地方法，调用start后jvm会为线程创建程序计数器、虚拟机栈和本地方法栈，但是线程具体什么时候启动则是由java线程调度器来决定。</p>
</blockquote>
<h3><span id="线程是否可以重新启动">线程是否可以重新启动？</span></h3><blockquote>
<p>start方法只能在初始态可以被调用，其他时候调用会报状态异常。</p>
</blockquote>
<h3><span id="如何实现线程同步">如何实现线程同步？</span></h3><blockquote>
<p>采用加锁的方式，分为乐观锁和悲观锁，乐观锁认为线程安全问题不会发生，即便发生了，我只需要判断条件进行相关操作即可，悲观锁认为线程安全问题一定发生，每次资源访问都会加锁，我们可以使用synchronized或者ReentrantLock或者其他互斥锁的方式对资源加锁，保证原子性和同步，还可以通过结合CAS和volatile乐观锁的方式来实现同步，比如使用原子类Automatic相关的类</p>
</blockquote>
<h3><span id="说一下对jmm的了解">说一下对JMM的了解？</span></h3><blockquote>
<p>JMM是java内存模型，抽象出了主存和缓存的概念，可以看做是并发下的一种规范，抽象出了happens-before原则来解决指令重排序等问题，帮助我们简化对多线程的开发。</p>
</blockquote>
<h3><span id="说说jvm内存区域和jmm的区别">说说JVM内存区域和JMM的区别？</span></h3><blockquote>
<p>这两个是不同的东西，JVM内存区域与程序运行相关，定义了程序数据的存放位置，JMM则与并发编程相关，抽象了线程和主内存的关系，规定了一些并发编程规范。</p>
</blockquote>
<h3><span id="说说happens-before">说说happens-before？</span></h3><blockquote>
<p>happens-before是JMM内存模型定义的一种并发编程规范，用于限制指令重排序，保证操作的可见性，表达的是前一种操作对后面的操作使可见的，无论是否在同一个线程中。</p>
</blockquote>
<h3><span id="并发编程3特性">并发编程3特性？</span></h3><blockquote>
<p>原子性、可见性、有序性</p>
<p>原子性即要么都发生要么都不发生，使用synchronized或者Lock锁实现。</p>
</blockquote>
<h3><span id="volatile原理">volatile原理？</span></h3><blockquote>
<p>volatile关键字可以保证变量的可见性和并发编程的有序性，这些是通过内存屏障的方式来实现的，被volatile修饰的变量在读时会在指令前加读屏障，在写时在指令后加写屏障，读屏障保证了读取的是当前的，要从主存中去获取，写屏障就保证写入指令之前的所有修改都会写入到内存中，而且有了读屏障，屏障前的指令不能重排序到屏障后，写屏障后的不能重排序到屏障前，这就禁止了指令重排序，保证了有序性。</p>
</blockquote>
<h3><span id="双重校验实现单例对象">双重校验实现单例对象？</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (singleton==<span class="keyword">null</span>)&#123;</span><br><span class="line">              log.debug(<span class="string">&quot;&#123;&#125;进入&quot;</span>,Thread.currentThread());</span><br><span class="line">              <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                  log.info(<span class="string">&quot;&#123;&#125;获得锁&quot;</span>,Thread.currentThread());</span><br><span class="line">                  <span class="keyword">if</span> (singleton==<span class="keyword">null</span>)&#123;</span><br><span class="line">                      singleton=<span class="keyword">new</span> Singleton();</span><br><span class="line">                  &#125;</span><br><span class="line">                  log.debug(<span class="string">&quot;对象已创建&quot;</span>);                &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> singleton;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">              <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                  Singleton singleton = Singleton.getSingleton();</span><br><span class="line">              &#125;).start();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>  为什么使用volatile呢，使用doublecheck的方式会存在线程安全问题，在synchronized块中，初始化操作分为多个指令，可能会先分配到内存空间和地址，但是还未初始化，这时候其他线程判断已经不为空了，去返回，但是此时还没有初始化，导致线程不安全，所以使用volatile禁止指令的重排序。</p>
<h3><span id="volatile可以保证原子性吗">volatile可以保证原子性吗？</span></h3><blockquote>
<p>volatile只能保证可见性，不能保证原子性。volatile保证了可见性，但不能保证多线程竞争下的一致性和原子性问题。可以使用synchronized、ReentrantLock、Atomatic原子类来保证操作原子性。</p>
</blockquote>
<h3><span id="什么是悲观锁">什么是悲观锁？</span></h3><blockquote>
<p>悲观锁假设最坏情况，悲观的认为线程安全问题一定会发生，所以在每次获取资源时都会上锁，其他线程都会得不到锁而阻塞，像synchronized、ReentrantLock这些独占锁都是悲观锁。不过悲观锁在高并发场景下会造成阻塞，频繁的上下文切换导致性能降低。</p>
</blockquote>
<h3><span id="什么是乐观锁">什么是乐观锁？</span></h3><blockquote>
<p>乐观锁是乐观的认为线程安全问题不会发生，线程可以继续运行，不用加锁也不用等待，只是验证一下资源有没有被修改，可以使用版本号法和CAS算法，像JUC包下的automatic等原子类就是利用了volatile的可见性和CAS来实现的乐观锁。</p>
</blockquote>
<h3><span id="乐观锁和悲观锁的优缺点">乐观锁和悲观锁的优缺点？</span></h3><blockquote>
<p>在高并发场景下，悲观锁会导致大量线程阻塞和频繁的上下文切换，拖慢性能，乐观锁则不存在锁竞争，也不好造成死锁和阻塞，但是如果频繁发生写操作的话，乐观锁就会频繁失败和重试，导致CPU飙升。悲观锁用于写入操作比较多的情况，乐观锁用于读操作的场景。</p>
</blockquote>
<h3><span id="实现乐观锁">实现乐观锁？</span></h3><blockquote>
<p>实现乐观锁可以通过版本号法和CAS算法来实现，版本号法一般是给数据加版本号，每次更新都会改变版本号，更新时也会判断版本号是否是当前版本号，是当前版本号时才会更新成功。</p>
<p>CAS全称为Compare And Swap，即比较并交换，思想就是通过一个原子性的操作，进行比较，相等则交换。</p>
</blockquote>
<h3><span id="乐观锁存在的问题">乐观锁存在的问题？</span></h3><blockquote>
<p>乐观锁只能保证相等才更新，但是两次相等间有没有发生其他操作是不可知的，如果有修改，CAS还是认为没有修改，这就是ABA问题，解决ABA问题可以利用版本号法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CasAba</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicReference atomicReference=<span class="keyword">new</span> AtomicReference(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;change A-&gt;B &#123;&#125;&quot;</span>, atomicReference.compareAndSet(atomicReference.get(), <span class="string">&quot;B&quot;</span>));</span><br><span class="line">        &#125;).start();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;change B-&gt;A &#123;&#125;&quot;</span>, atomicReference.compareAndSet(atomicReference.get(), <span class="string">&quot;A&quot;</span>));</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;main 。。。start&quot;</span>);</span><br><span class="line">        CasAba casAba = <span class="keyword">new</span> CasAba();</span><br><span class="line">        casAba.method();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;change A-&gt;C &#123;&#125;&quot;</span>, casAba.atomicReference.compareAndSet(casAba.atomicReference.get(), <span class="string">&quot;C&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用AtomicStampedReference来解决ABA问题。</p>
<p>CAS经常需要自旋来重试，一直不成功的话，会给CPU带来极大的开销。</p>
<p>乐观锁只能对单个共享变量有效，涉及到多个共享变量CAS是无效的。</p>
</blockquote>
<h3><span id="synchronized是什么有什么作用">synchronized是什么，有什么作用？</span></h3><blockquote>
<p>synchronized关键字用于实现线程同步，保证被它修饰的方法和代码块同一时刻只能被一个线程运行，属于重量级锁，synchronized加锁时会与操作系统中的monitor进行绑定，owner记录当前锁住的线程，entryList中是被阻塞的线程，waitSet中是wait进入等待的线程，是独占悲观锁，在高并发场景下可能会导致线程上下文频繁切换，使性能降低，不过也对synchronized进行了优化，比如偏向锁和轻量级锁。</p>
</blockquote>
<h3><span id="怎么使用synchronized">怎么使用synchronized？</span></h3><blockquote>
<p>可以加在方法和代码块上。</p>
<p>加在非静态方法则锁当前实例对象，加静态方法上则锁当前类，修饰代码块则要指定对象锁。</p>
<p>一般不给String类型加锁，因为String会在堆中有缓存，导致String可能会相等，对象锁不唯一。</p>
</blockquote>
<h3><span id="构造器可以加synchronized吗">构造器可以加synchronized吗？</span></h3><blockquote>
<p>构造器本身就是线程安全的。</p>
</blockquote>
<h3><span id="synchronized原理">synchronized原理？</span></h3><blockquote>
<p>底层是使用monitorenter和monitorexit指令来标志同步块的，加在方法上则是用ACC_SYNCHRONIZED标志同步方法，本质上是获取monitor监视器，监视器的owner记录锁住的线程，entryList存放获取锁阻塞的线程，wait中放执行了wait方法等待唤醒的线程。</p>
</blockquote>
<h3><span id="synchronized和volatile的区别">synchronized和volatile的区别？</span></h3><blockquote>
<p>synchronized和volatile是互补的，volatile可以保证可见性但是不能保证原子性，synchronized可以保证原子性，volatile比synchronized的性能要好，volatile原理是内存屏障，synchronized原理是monitor，volatile只能修饰变量。</p>
</blockquote>
<h3><span id="reentrantlock是什么">ReentrantLock是什么？</span></h3><blockquote>
<p>ReentrantLock是可重入的独占锁，和synchronized都是悲观锁，不过功能更强大，增加了超时、中断、多条件变量和公平锁的功能，内部有内部类sync以及其子类公平锁和非公平锁，sync继承自AQS，ReentrantLock底层就是使用的AQS的互斥锁。</p>
</blockquote>
<h3><span id="公平锁和非公平锁的区别">公平锁和非公平锁的区别？</span></h3><blockquote>
<p>公平锁：锁被释放之后，先申请的线程先得到锁，后申请的后得到锁，性能较差。</p>
<p>非公平锁：锁释放之后，是随机得到锁的，但是可能造成有线程永远获取不到锁的情况。</p>
</blockquote>
<h3><span id="synchronized和reentrantlock的区别">synchronized和ReentrantLock的区别</span></h3><blockquote>
<p>两者都是可重入的独占锁，synchronized依赖于JVM，ReentrantLock依赖于API，底层是AQS，ReentrantLock的功能更为强大，提供了超时等待、等待打断、多条件变量、公平锁的功能。</p>
</blockquote>
<h3><span id="reentrantreadwritelock是什么">ReentrantReadWriteLock是什么？</span></h3><blockquote>
<p>这是一种读写锁，里面有读锁也有写锁，即保证了读的效率，也保证了写的安全，有点类似数据库中的共享锁和排它锁。只有同时读时可以锁共存的，其他的行为都是互斥的。同样是基于AQS实现的，在读多写少的情况下比较适用读写锁。我们可以利用读写锁去写类似于Mybatis的缓存，保证读写互斥，使双写数据一致。</p>
</blockquote>
<h3><span id="共享锁和独占锁的区别">共享锁和独占锁的区别？</span></h3><blockquote>
<p>共享锁是多个线程都可以获得的锁，独占锁是一个锁只能被一个线程获得。</p>
</blockquote>
<h3><span id="读锁为什么不能升级为写锁">读锁为什么不能升级为写锁？</span></h3><blockquote>
<p>写锁可以降级为读锁，读锁不能升级为写锁。</p>
</blockquote>
<h3><span id="stampedlock">StampedLock？</span></h3><blockquote>
<p>StampedLock也是读写锁，不过读时乐观读的方式，它是通过加戳和验戳的方式判断有没有进行写操作，如果戳没有改变则是一直在读，则不加锁，如果发生了改变，就要加一次读锁，适用于读多写少的场景，不过它不支持多条件变量，也不是可重入锁。</p>
</blockquote>
<h3><span id="atomic原子类重点">Atomic原子类（重点）</span></h3><h3><span id="什么是原子类">什么是原子类？</span></h3><blockquote>
<p>在JUC的atomic包下的类，是具有原子特征的类。即操作要么同时发生要么都不发生。</p>
</blockquote>
<h3><span id="有哪些原子类">有哪些原子类？</span></h3><blockquote>
<ul>
<li>原子整数：AtomicInteger、AtomicLong、AtomicBoolean</li>
<li>原子数组：AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray</li>
<li>原子引用：AtomicReference、AtomicStampedReference</li>
<li>字段修改器:AtomicIntegerFieldUpdater、AtomicLongFieldUpdater、AtomicReferenceFieldUpdater</li>
</ul>
</blockquote>
<h3><span id="原子整数基本方法">原子整数基本方法？</span></h3><blockquote>
<ul>
<li>get()获取当前值</li>
<li>getandset获取并设置新值</li>
<li>getandincrement i++</li>
<li>getanddecrement i–</li>
<li>getandadd i =i+n</li>
<li>compareandset 比较并修改</li>
</ul>
<p>底层是Unsafe的CAS+volatile实现的</p>
</blockquote>
<h3><span id="原子数组">原子数组？</span></h3><blockquote>
<p>和原子整数类似，不过是修改数组指定位置的元素，进行CAS</p>
</blockquote>
<p>   <img src="/2023/08/01/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/image-20230827152043539.png" alt="image-20230827152043539"></p>
<h3><span id="原子引用">原子引用？</span></h3><blockquote>
<p>类似上述，不过会有ABA问题，可以用AtomicStampedReference加版本号的方式来解决。</p>
</blockquote>
<h3><span id="字段修改器">字段修改器？</span></h3><blockquote>
<p>Updater,可以CAS修改对象中的字段。</p>
</blockquote>
<h3><span id="什么是线程池">什么是线程池？</span></h3><blockquote>
<p>线程池用于管理线程，是一系列线程的资源池，是享元模式的一种体现，使用线程池可以帮助我们避免同类线程的重复创建、帮助我们更好的管理线程，降低资源消耗。</p>
</blockquote>
<h3><span id="创建线程池的方式">创建线程池的方式？</span></h3><blockquote>
<p>创建线程池的方式有两种，一种是通过ThreadPoolExecutor构造器的方式创建，一种是通过Executors方法类的方式创建。</p>
<p>Executors中有多种线程，一种是FixedThreadPool，生成固定线程数量的线程池，如果没有则到任务队列中，使用的是LinkedBlockingQueue，一种是SingleThreadExecutor，是只有一个线程的线程池，其他线程进入LinkedBlokingQueue队列中，还有就是CachedThreadPool，核心线程数为0，最大线程数是Integer.maxsize，如果没有新任务提交，会超时销毁，ScheduledThreadPool使用的是延迟队列，用于给定延迟时间执行或者固定时间执行的业务。</p>
</blockquote>
<h3><span id="为什么不使用executors">为什么不使用Executors？</span></h3><blockquote>
<p>使用内置线程池，可能会导致OOM问题。</p>
<p>如果使用FixedThreaPool和SingleThreadExecutors，他们使用的是无解阻塞队列，如果线程执行速度比较慢的情况或者线程太多，就会导致请求阻塞过多，导致OOM问题。如果使用的是CachedThreadPool，它是设置核心线程数为0，最大线程数为Integer.maxsize，所以会导致创建的线程过多，导致OOM问题，如果使用ScheduledThreadPool，它使用的是延迟队列，也会导致阻塞线程过多，导致OOM问题。</p>
</blockquote>
<h3><span id="线程池常见参数">线程池常见参数？</span></h3><blockquote>
<p>核心线程数，最大线程数，超时等待时间，时间单位，任务队列，线程工厂，拒绝策略</p>
</blockquote>
<h3><span id="线程池饱和策略">线程池饱和策略？</span></h3><blockquote>
<p>AbortPolicy:抛出异常拒绝新任务</p>
<p>CallerRunPolicy：在当前executor的线程运行新任务，会导致影响主线程速度，会保证所有任务都执行。</p>
<p>DiscardPolicy：不处理，直接丢弃</p>
<p>DiscardOldestPolicy：丢弃最早的未处理的线程。</p>
</blockquote>
<h3><span id="线程池的队列">线程池的队列？</span></h3><blockquote>
<p>LinkedBlockingQueue：无界阻塞队列，FixedThreadPool和SingleThreadExecutor是用的这个，可能会导致大量请求被阻塞。</p>
<p>SynchronousQueue：同步队列，不用于存储元素，目的是有空闲线程就使用，没有就新创建救急线程，CachedThreadPool是使用的同步队列，最大线程数是Integer.size，可能会导致线程过多，OOM。</p>
<p>DelayWorkQueue：延迟队列，会自动扩容，永远不会满，所以会导致大量请求阻塞</p>
</blockquote>
<h3><span id="线程池的运行流程">线程池的运行流程？</span></h3><blockquote>
<p>提交任务，判断核心线程池是不是已经满了，如果没有满，有空闲线程，就创建线程，如果满了则放入任务队列中，如果任务队列也满了，就再去看线程池有没有满，如果有空闲线程了，就可以创建线程，如果没有空闲线程，就按照拒绝策略处理。</p>
</blockquote>
<h3><span id="怎么给线程池命名">怎么给线程池命名？</span></h3><blockquote>
<p>使用ThreadFactoryBuilder或者我们自定义线程工厂，其中设置起名规则。</p>
</blockquote>
<h3><span id="线程池的大小该怎么选取">线程池的大小该怎么选取？</span></h3><blockquote>
<p>线程池的大小并不是越大越好，线程过多可能会使线程上下文频繁切换，拖慢系统性能。</p>
<p>上下文切换，线程都有自己的运行状态，包括程序计数器、虚拟机栈和本地方法栈等，当需要发生线程切换的时候就会需要保存当前线程状态，下一次再加载，会拖慢性能。</p>
<p>线程池太小的话又会导致可能会导致阻塞请求过多，发生OOM问题。</p>
<p>CPU密集型的任务，采用CPU核数+1的大小，这样能很好的利用CPU，而且当出现问题时，多出来的线程可以充分利用空闲时间。</p>
<p>IO密集型可以大致认为是核心数的2倍</p>
<p>具体计算应该是</p>
<p>核心数*（1+等待时间/运行时间）,CPU型的等待时间几乎没有，所以是N+1，IO型几乎全是等待时间，所以可以认为是2N。</p>
</blockquote>
<h3><span id="future作用">Future作用</span></h3><blockquote>
<p>是一种设计模式，思想是异步调用，用于将耗时的任务交由子线程异步执行，不影响其他线程，可以提高执行效率。</p>
<p>用cancle取消任务，iscancled判断任务是否被取消，isdone是否执行结束，get获取结果，get（）超出时间则抛出异常</p>
</blockquote>
<h3><span id="futuretask">FutureTask</span></h3><blockquote>
<p>是Future接口的实现类，用于封装Callable和Runnable接口，可以查看任务是否执行成功，是否被取消，是否能获取到结果，线程池的submit方法其实就是返回的FutureTask。</p>
</blockquote>
<h3><span id="说一下线程池原理">说一下线程池原理？</span></h3><blockquote>
<p>线程池体现了是享元模式的实现，池中创建了多个线程，可以避免线程的重复创建，减少资源的损耗，并且能让我们对线程有更好的管理，线程池有几个核心参数，我们在创建线程池的时候指定核心线程数，最大线程数和任务队列，在我们调用execute方法的时候，要先判断核心线程池有没有空闲，有空闲则创建线程，没有空闲则进入任务队列中，如果任务队列已满，则看是否有空闲的救急线程，有则创建线程，没有则根据解决策略处理。</p>
</blockquote>
<h3><span id="runnable-vs-callable">Runnable VS Callable</span></h3><blockquote>
<p>Callable可以返回结果和抛出异常，Runnable不可以，在不需要返回结果和抛出异常的时候，使用Runnable更简洁。</p>
<p>executor可以将runnable转换为Callable</p>
</blockquote>
<h3><span id="execute和submit的对比">execute和submit的对比</span></h3><blockquote>
<p>execute只能处理Runnable，submit能处理Callable和Runnable，会返回futureTask，其中包含异常信息和结果。</p>
</blockquote>
<h3><span id="shutdown和shutdownnow的区别">shutdown和shutdownnow的区别</span></h3><blockquote>
<p>shutdown会等已提交的所有线程都执行完，线程池状态变成shutdown，shutdownnow会变成stop，结束当前任务，停止排队任务。</p>
</blockquote>
<h3><span id="aqs详解">AQS详解</span></h3><h4><span id="什么是aqs">什么是AQS？</span></h4><blockquote>
<p>AQS是多线程同步器，全称是AbstractQueuedSynchronizer，用于构建锁和同步器，juc下的很多组件都是基于AQS实现的，比如ReentrantLock、ReentrantReadandWriteLock、countdownlatch。</p>
</blockquote>
<h4><span id="aqs原理">AQS原理</span></h4><blockquote>
<p>AQS是多线程同步器，全称是AbstractQueuedSynchronizor，它是JUC包中许多组件的底层实现，比如lock、countdownlatch、semaphore都是基于AQS来实现的，AQS提供了两种锁机制，分别是共享锁和排它锁，排它锁就是多个线程竞争同一共享资源的时候只能被一个线程所获得，比如ReentrantLock就是用到了AQS的排他锁，共享锁也叫读锁，允许多个线程同时获取到锁的资源，比如countdownlatch和ReentrantReadAndWriteLock和Semaphore都用到了AQS的共享锁，我们需要自定义同步器的话就需要重写相关的方法，比如tryacquire、tryRelease实现排它锁，tryacquireshared，tryrelease实现共享锁，对于获取不到锁的线程，AQS会创建一个双向链表来存储这些Node，每一个结点都有自己的等待状态。</p>
</blockquote>
<h4><span id="reentrantlock实现原理">ReentrantLock实现原理</span></h4><blockquote>
<p>是基于AQS的排他锁实现的，默认是非公平锁，它和synchronized都是独占可重入锁，但是ReentrantLock的功能更强，是可打断的，是可以设置超时等待时间的，是可以实现公平锁的，是可以实现多条件变量的。</p>
<p>lock–&gt;sync.lock</p>
<p>sync是继承AQS的，非公平锁的话会直接CAS更新state，如果更新成功就记录当前线程为锁的持有者，否则执行acquire方法，acquire方法，acquire方法会先执行非公平锁的tryacquire方法，如果state为0，就CAS尝试加锁，成功则设置当前线程为锁持有者，不为0则判断锁持有者是否是当前线程，是则state+1，这也是实现可重入锁的关键，否则就加锁失败，如果加锁失败则调用addWaiter方法进入到阻塞队列中，然后调用外部的acquireQueued方法，判断当前线程是否是队列第一个，如果是，则重新CAS尝试获取到就可以出队，获取不到就park当前线程。释放锁则是将state-1，减到0则是释放锁，判断头结点是否为空，并且头结点的状态是否不等于0，如果不等于0就可以unpark。公平锁就需要在tryrequire的时候，判断队列是否为空，不为空的话就要加在队列中，为空则可以继续CAS判断是否可以加锁成功。</p>
</blockquote>
<h2><span id="数据结构及算法">数据结构及算法</span></h2><h3><span id="查找算法">查找算法</span></h3><h4><span id="二分查找">二分查找</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对有序的数组可以使用二分查找，实际上是设置指针来进行移动</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=arr.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">int</span> index=(left+right)&gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[index]==target)&#123;</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (arr[index]&lt;target)&#123;</span><br><span class="line">                left=index+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right=index-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//为什么使用left&lt;=，因为如果等于也是要比较的，直接退出是错误的</span></span><br><span class="line"><span class="comment">//为什么要右移？因为如果是（left+right）/2的话，会先进行增加，算出来的结果可能会溢出导致结果不对，使用右移就能很好解决除法问题</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种方法是将right作为一定不相等的边界</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch2</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=arr.length;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> index=(left+right)&gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[index]==target)&#123;</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (arr[index]&lt;target) left = index + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                right=index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//减小比较次数，使更稳定,平衡版就是不断的去缩小范围，在循环外比较，时间复杂度是平衡的，不会出现左右不一致的情况</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch3</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=arr.length;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>&lt;right-left)&#123;</span><br><span class="line">            <span class="keyword">int</span> index=(right+left)&gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[index]&gt;target)&#123;</span><br><span class="line">                right=index;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                left=index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[left]==target)&#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//LeftMost 查找最左的target，其他逻辑不便，需要中间变量记录target位置，并且，不是直接返回，而是继续查找。</span></span><br><span class="line"><span class="comment">//LeftMost 求第一次出现的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">LeftMost</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=arr.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> temp=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">int</span> index=(left+right)&gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[index]&lt;target)&#123;</span><br><span class="line">                left=index+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[index]&gt;target)&#123;</span><br><span class="line">                right=index-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                temp=index;</span><br><span class="line">                right=index-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//RightMost 简单，和LeftMost对换就行了，left+1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">LeftMost</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=arr.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> temp=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">int</span> index=(left+right)&gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[index]&lt;target)&#123;</span><br><span class="line">                left=index+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[index]&gt;target)&#123;</span><br><span class="line">                right=index-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                temp=index;</span><br><span class="line">                left=index+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5><span id="二分查找并返回插入点">二分查找，并返回插入点</span></h5><blockquote>
<p>实际上，左索引就是插入点</p>
<p>题目描述：给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>题解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、传统二分</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">int</span> index=(left+right)&gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[index]&lt;target)&#123;</span><br><span class="line">                left=index+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[index]&gt;target)&#123;</span><br><span class="line">                right=index-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//2、Arrays工具类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> answer = Arrays.binarySearch(nums, target);<span class="comment">//返回的是-left-1</span></span><br><span class="line">        <span class="keyword">if</span> (answer&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            answer=~answer;<span class="comment">//~answer=-answer-1;得到的还是left</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5><span id="搜索二维矩阵">搜索二维矩阵</span></h5><blockquote>
<p>给你一个满足下述两条属性的 <code>m x n</code> 整数矩阵：</p>
<ul>
<li>每行中的整数从左到右按非递减顺序排列。</li>
<li>每行的第一个整数大于前一行的最后一个整数。</li>
</ul>
<p>给你一个整数 <code>target</code> ，如果 <code>target</code> 在矩阵中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p>由于是已经排序过的，所以第一列是有序的，可以在第一列进行二分查找确定插入点，再去行中找元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//由于矩阵中每行第一个元素大于上一行最后一个元素，第一列是有序的，先判断元素在第几行</span></span><br><span class="line">        <span class="keyword">int</span> row = searchcolumn(matrix, target);</span><br><span class="line">        <span class="comment">//查找行中是否有target</span></span><br><span class="line">        <span class="keyword">if</span>(row&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> answer = Arrays.binarySearch(matrix[row], target);</span><br><span class="line">        <span class="keyword">if</span> (answer&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">searchcolumn</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=matrix.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">int</span> index=(left+right)&gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (matrix[index][<span class="number">0</span>]&lt;target)&#123;</span><br><span class="line">                left=index+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (matrix[index][<span class="number">0</span>]&gt;target)&#123;</span><br><span class="line">                right=index-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5><span id="寻找峰值">寻找峰值</span></h5><blockquote>
<p>峰值元素是指其值严格大于左右相邻值的元素。</p>
<p>给你一个整数数组 <code>nums</code>，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 <strong>任何一个峰值</strong> 所在位置即可。</p>
<p>思路：利用二分，1,5,6,4,9,8,6,11,43，让left=0,right=length-1，如果中间值大于右边值，则证明左边有极值，right=index，如果小于右边值，则右边有极值,left=index+1</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=nums.length-<span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> index=(left+right)&gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[index]&gt;nums[index+<span class="number">1</span>])&#123;</span><br><span class="line">                right=index;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left=index+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


</blockquote>
<h2><span id="操作系统">操作系统</span></h2><h3><span id="linux常见命令">Linux常见命令</span></h3><h4><span id="vim相关">vim相关</span></h4><blockquote>
<p>vim 1.txt 进入普通vim模式</p>
<p>普通模式下可以进行复制删除和修改</p>
<p>yy 复制光标当前行，5yy复制五行，y^复制到行头，y$复制到行尾 yw复制一个单词</p>
<p>dd 删除 5dd删除五行，dw删除单词</p>
<p>p 粘贴 5p粘贴五次</p>
<p>u撤销 </p>
<p>r替换 R替换</p>
<p>gg跳转到首行G到尾行</p>
<p>dgg从当前行到行首都删除</p>
<p>dG从当前行到行尾都删除</p>
<p>按i、o、a、I、O、A进入编辑模式</p>
<p>i是当前光标，o是下一行，</p>
<p>O是上一行，A是行尾，I是行首</p>
<p>命令模式下</p>
<p>:q退出 :q!强制退出 :w 保存 :wq保存并退出 :wq!无视只读进行保存 /进行查找 n是下一个，b是上一个。</p>
<p>:s/old/new替换第一个，:s/old/new/g替换当前行所有 :%s/old/new/g 替换所有行所有</p>
</blockquote>
<h4><span id="配置虚拟机网络">配置虚拟机网络</span></h4><blockquote>
<p>vmware提供了三种网络连接模式：桥接、nat和仅主机。</p>
<p>桥接是在虚拟机和PC机之间建立网桥和交换机进行网络连接</p>
<p>nat是给pc机建立网卡和路由器，将网络分发到虚拟机上，使虚拟机可以访问外网。</p>
<p>vim /etc/sysconfig/network-scripts/ifcfg-ens33</p>
<p>把虚拟机设置为静态ip</p>
<p>TYPE=Ethernet<br>PROXY_METHOD=none<br>BROWSER_ONLY=no<br>BOOTPROTO=static<br>DEFROUTE=yes<br>IPV4_FAILURE_FATAL=no<br>IPV6INIT=yes<br>IPV6_AUTOCONF=yes<br>IPV6_DEFROUTE=yes<br>IPV6_FAILURE_FATAL=no<br>IPV6_ADDR_GEN_MODE=stable-privacy<br>NAME=ens33<br>UUID=ef980217-9ca0-45a6-9e39-11f7c3f48b13<br>DEVICE=ens33<br>ONBOOT=yes<br>IPADDR=192.168.64.128<br>GATEWAY=192.168.64.2<br>DNS1=192.168.64.2</p>
<p>重启网络</p>
<p>service network start</p>
<p>修改主机名</p>
<p>hostnamectl set-hostname ssl</p>
</blockquote>
<h4><span id="系统管理">系统管理</span></h4><blockquote>
<p>Centos6中使用</p>
<p>service 服务名 stop/start/restart 来管理服务</p>
<p>Centos7中使用</p>
<p>systemctl start/stop/restart 服务名来进行服务的管理</p>
<p>比如：</p>
<p>service network restart</p>
<p>systemctl restart network</p>
<p>setup可以进入到系统服务</p>
<p>systemctl  start|status|stop|disable|enable 服务名  分别代表：启动|状态|停止|开机不自启|开机自启</p>
<p>常见内置服务包括：NetworkManager 主网络服务 network副网络服务 firewalld防火墙服务 sshd ssh远程连接服务</p>
</blockquote>
<h4><span id="文件操作命令">文件操作命令</span></h4><blockquote>
<p>ls [-a -l -h] [路径] 列出路径下的内容</p>
<p>cd [路径] 切换目录</p>
<p>pwd 输出当前目录</p>
<p>cd ~回到home目录</p>
<p>cd /回到根目录</p>
<p>mkdir [-p] 路径 创建文件夹 -p可以创建连续多级文件夹</p>
<p>touch 路径 用于创建文件</p>
<p>cat/more 文件名 可以读取文件，more支持翻页，按空格翻页，按q退出</p>
<p>cp [-r] 路径1 路径2 将路径1的文件夹或文件复制到路径2，-r代表复制文件夹时递归复制，把文件夹中的内容也复制过去</p>
<p>mv 路径1 路径2 将路径1的文件夹或文件剪切到路径2</p>
<p>rm [-r -f] 路径1 路径2 。。。。。用于删除文件或文件夹，-r可以删除文件夹，-f是强制删除，此外，可接受多个参数进行批量删除，rm也支持通配符，*表示任意</p>
<p>which 命令 用于查找命令的执行文件</p>
<p>find 起始路径 -name “文件名” 按名查找文件</p>
<p>find 起始路径 -size +|-n[KMG] +表示大于-表示小于，n表示数值，KMG表示单位，比如查询文件大小小于10k的文件，find / -size -10k,查找文件大小大于100M的文件：find / -size +100M</p>
<p>grep [-n] 关键字 文件路径 查询关键字在文本中的行号，比如grep “ssl” text.txt</p>
<p>wc [-c -m -l -w] 文件名 统计字节数、字符数、行数、单词数</p>
<p>| 将左边的结果作为右边的输入，搭配grep使用可以做一些匹配，cat test.txt |grep itheima，cat test.txt |wc -l ,ls |grep test,ls -l /usr/bin |wc -l</p>
<p>echo 输出</p>
<p>echo “hello” &gt;test.txt覆盖写入，echo “hello” &gt;&gt;test.txt追加写入，&gt; 左边的结果覆盖写入右边，&gt;&gt;左边的结果追加写入右边文件</p>
<p>tail [-f -num] 文件路径 获取尾部信息，-f实时监控，-num限制获取尾部几行</p>
</blockquote>
<h4><span id="权限指令">权限指令</span></h4><blockquote>
<p>su [-] 用户名，切换用户，默认切换到root</p>
<p>exit退出root</p>
<p>进行sudo认证：visudo  尾部添加 ptsnake ALL=(ALL) NOPASSWORD:ALL,这样执行sudo语句就不需要输入密码了</p>
<p>groupadd 用户组 创建用户组</p>
<p>groupdel 用户组 删除用户组</p>
<p>useradd 用户名 [-g -d] [用户组 路径] 创建用户，-g指定用户组，-d指定文件位置，默认是/home下</p>
<p>userdel 用户名 删除用户</p>
<p>usermod -aG 用户组 用户名 将用户加入到指定用户组中</p>
<p>gpasswd -d 用户名 用户组 将用户从指定用户组移除</p>
<p>getent passwd 展示所有用户</p>
<p>getent group 展示所有用户组</p>
<p>认识权限：</p>
<p>ls -l 可以看到所有文件的权限信息和用户及用户组信息，其中权限信息有十位，第一位表示文件类型，d即文件夹，-表示文件，l表示软链接，之后九位分别代表当前用户权限，当前用户组权限和其他用户权限，rwx，r是读，w是写，x是运行权限或可cd进入</p>
<p>chmod命令：可以用chmod命令来修改文件或文件夹的权限，chmod u=rwx,g=rx,o=x 文件名。chmod -R u=rwx,g=rx,o=x 文件夹，文件夹中的所有都将有该权限。也不用这么麻烦，权限也可以使用数字表示，比如751，表示u=rwx,g=rx,o=x。权限以二进制表示，001表示–x，111表示rwx，100表示r，010表示w，101表示rx，110表示rw，011表示wx</p>
<p>chown命令：用于修改文件或文件夹的用户组，chown [-R] [用户] [:] [用户组] 文件名,该命令只能在root用户下使用。</p>
</blockquote>
<h4><span id="防火墙命令">防火墙命令</span></h4><blockquote>
<p>systemctl stop firewalld 关闭防火墙</p>
<p>systemctl start firewalld 开启防火墙</p>
<p>systemctl disable firewalld 开机不自启</p>
<p>systemctl enable firewalld 开机自启</p>
<p>firewalld-cmd –list-all 防火墙规则</p>
<p>firewalld-cmd –query-port=8080/tcp 查询防火墙端口是否开放</p>
<p>firewalld-cmd –permanent –add-port=80/tcp 开启端口</p>
<p>firewalld-cmd –permanent –remove-port=8080/tcp 关闭端口</p>
<p>firewalld-cmd –reload 重启防火墙</p>
</blockquote>
<h4><span id="linux实用命令">Linux实用命令</span></h4><h5><span id="快捷键">快捷键</span></h5><blockquote>
<p>ctrl c停止，换行重新输入</p>
<p>ctrl d退出登录或者退出某些程序的专属页面</p>
<p>history 来看历史命令，可以搭配|grep使用</p>
<p>!加前缀可以执行相匹配的最近的那个命令，比如!py就能执行python这个命令</p>
<p>ctrl r可以搜索历史命令，回车执行，左右键进行获得</p>
<p>ctrl a跳至命令头，ctrl e跳至命令尾</p>
<p>ctrl 左右键，前后跳一个单词</p>
<p>ctrl l 等同于clear进行清屏 </p>
</blockquote>
<h5><span id="软件安装">软件安装</span></h5><blockquote>
<p>Centos的应用商店为yum，Ubantu的应用商店是apt</p>
<p>yum [-y] [install|remove|search] 软件 -y是自动确认，install下载，remove卸载，search搜索</p>
<p>yum install wget 安装wget</p>
<p>yum install ntp 安装ntp</p>
<p>yum install httpd 安装httpd</p>
</blockquote>
<h5><span id="软链接">软链接</span></h5><blockquote>
<p>类似于快捷方式</p>
<p>ln -s 原地址 快捷方式地址</p>
<p>如：ln -s ~/nice/test ~/test</p>
</blockquote>
<h5><span id="日期和时区">日期和时区</span></h5><blockquote>
<p>date [-d] [+格式化字符串] 获取格式化时间，-d可以进行计算</p>
<p>修改时区：</p>
<p>rm -f /etc/localtime</p>
<p>sudo ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</p>
<p>自动校验时间：安装ntp，开机自启，会自动联网校准</p>
</blockquote>
<h5><span id="网络请求和下载">网络请求和下载</span></h5><blockquote>
<p>ping [-c num] 用于心跳检测网络通不通，-c 用于指定多少次</p>
<p>wget [-b] url 下载网络文件，-b是后台下载</p>
<p>curl [-O] url 用于发送http请求，-O用于下载文件时</p>
</blockquote>
<h5><span id="端口">端口</span></h5><blockquote>
<p>nmap 查看端口占用情况</p>
<p>netstat 查看指定端口的占用情况</p>
<p>netstat -anp|grep 端口号</p>
</blockquote>
<h5><span id="进程">进程</span></h5><blockquote>
<p>ps [-e -f]查看进程信息，-e展示全部进程，-f，格式化展示全部信息，一般就是ps -ef</p>
<p>比较重要的信息：uid启动用户、pid进程id、time运行时间、cmd启动位置，可以配合|grep使用</p>
<p>kill -9 进程号 用于杀死进程</p>
</blockquote>
<h5><span id="环境变量">环境变量</span></h5><blockquote>
<p>export 变量名=变量值  用于设置临时环境变量</p>
<p>env可以查看所有全局环境变量</p>
<p>set可以查看所有全局和非全局的环境变量</p>
<p>vim ~/.bashrc ，在此文件中进行编辑环境变量，之后source 命令让文件生效就能永久对该用户保存环境变量</p>
<p>vim /etc/profile 在此文件进行编辑环境变量，source生效后，就会所有用户永久生效。</p>
</blockquote>
<h5><span id="上传和下载">上传和下载</span></h5><blockquote>
<p>通过图形化的界面去上传下载</p>
<p>或者使用 rz命令下载，sz命令上传</p>
</blockquote>
<h5><span id="压缩和解压">压缩和解压</span></h5><blockquote>
<p>常见的压缩格式包括：zip、7zip、rar、tar、gzip，其中tar和gzip是linux比较常用的</p>
<p>tar命令：tar [-c -v -f -z -x -C]</p>
<ul>
<li>-c 打包文件，压缩必须的参数</li>
<li>-v 显示进度条</li>
<li>-f 指定要创建的压缩文件名或者要解压的压缩包</li>
<li>-z gzip模式，使用gz算法进行压缩</li>
<li>-x 解压</li>
<li>-C 选择解压文件目录</li>
</ul>
<p>组合: tar -cvf test.rar 1.txt 2 .txt</p>
<p>-cvf 即指定压缩包名，显示进度条的压缩</p>
<p>-zcvf 即使用zg算法的压缩</p>
<p>tar -xvf 压缩包名 -C 压缩目录</p>
<p>tar -zxvf 压缩包名 -C 压缩目录</p>
<p>zip命令：</p>
<p>zip -r xxx.zip 文件1 文件2 。。。。。</p>
<p>unzip [-d] 压缩包 进行解压</p>
</blockquote>
<h3><span id="shell编程">Shell编程</span></h3><blockquote>
<p><strong>局部变量和全局变量</strong></p>
<p>局部变量不被子shell读取，全局变量才可以被子shell访问，全局变量要加export，readonly可以定义只读变量。</p>
<p>$n可以用于接收参数，$0即脚本名称，$1是第一个参数，以此类推，$#用于获取参数个数，$?用于得到上一条指令的执行情况，0为成功</p>
<p><strong>运算符：</strong></p>
<p>$[]或者$(())来进行运算</p>
<p><strong>比较运算符：</strong></p>
<p>-eq 等于 -lt （less than）小于 -le （less equal）小于等于 -ne （not equal）不等于 -gt （greater than）大于 -ge（greater equal）大于等于，-r/w/x 判断是否有可读/可写/可执行 的权限，-e/f/d 判断文件是否存在/是否是文件/是否是文件夹</p>
<p><strong>条件判断：</strong></p>
<p>使用[ condition ]来进行条件判断，必须加空格，多条件时-a表示and，-o表示or</p>
<p><strong>分支if：</strong></p>
<p>if [ condition ]</p>
<p>then</p>
<p>程序</p>
<p>elif [ condition ]</p>
<p>then</p>
<p>程序</p>
<p>else</p>
<p>程序</p>
<p>fi</p>
<p><strong>多分支case</strong></p>
<p>case a in</p>
<p>“值1”) 程序</p>
<p>;;</p>
<p>“值2”) 程序</p>
<p>;;</p>
<p>*) 程序</p>
<p>;;</p>
<p>esac</p>
<p><strong>for循环</strong></p>
<p>sum=0</p>
<p>for((i=0;i&lt;=100;i++))</p>
<p>do </p>
<p>​    sum=$[$sum+$i]</p>
<p>done</p>
<p>echo $sum</p>
<p>for i in {0..10}</p>
<p>do</p>
<p>done</p>
<p><strong>while循环</strong></p>
<p>while [ condition ]</p>
<p>do</p>
<p>done</p>
<p><strong>read读取</strong></p>
<p>read -t -p “….” name</p>
<p>-t指定输入时间，-p指定提示信息，name表示接受参数</p>
<p><strong>函数</strong></p>
<p>function getsum()</p>
<p>{</p>
<p>​    echo $[$1+$2]</p>
<p>}</p>
<p>read -p “数1：” a</p>
<p>read -p “数2：” b</p>
<p>sum=$(getsum $a $b)</p>
<p>echo $sum</p>
<p>案例练习：</p>
</blockquote>
<h2><span id="计算机网络">计算机网络</span></h2><h3><span id="什么是计算机网络">什么是计算机网络？</span></h3><blockquote>
<p>计算机网络实现了不同地理位置的多台计算机之间通过通信线路连接进行资源共享和信息传递。</p>
</blockquote>
<h3><span id="osi七大模型">OSI七大模型?</span></h3><blockquote>
<p>应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。</p>
<p>应用层：为用户提供服务，常见的应用协议就在应用层，比如HTTP、FDP、DNS等。</p>
<p>表示层：用于数据处理，比如加解密、编码解码。</p>
<p>会话层：用于管理应用程序之间的会话。</p>
<p>传输层：为两台主机提供数据传输服务，比如TCP、UDP协议</p>
<p>网络层：用于路由和寻址，决定数据的游走路径</p>
<p>链路层：通过帧进行物理寻址</p>
<p>物理层：进行bit流透明传输</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-ip-4-model.png" alt="TCP/IP 四层模型"></p>
</blockquote>
<h3><span id="tcpip模型">TCP/IP模型</span></h3><blockquote>
<p>应用层、传输层、网络层、网络接口层。</p>
<p>应用层：应用层用于给用户提供功能，比如HTTP、FTP、DNS这些应用协议都是在应用层的。</p>
<p>传输层：接收到应用层的数据包，进行主机之间的通信，有TCP和UDP两种协议。UDP比较简单，只负责发送数据包，是不可靠传输，不过实时性和传输效率比较高。TCP的话全称是传输控制协议，很多都是基于TCP的，比如HTTP，它提供了流量控制、超时重传、阻塞控制等，比UDP更可靠，当传输包过大时，会进行分段，进行TCP分段传输，如果有失败的只需要重新发送段就可以了。</p>
<p>网络层：我们不希望传输层处理太多的事情，只需要服务好应用层即可，只作为媒介，具体的数据传输工作则是交给网络层的。负责路由和选址。常见协议就是IP协议，寻址寻找子网来决定网络传输的方向，路由则是选址路径，找到目标计算机。</p>
<p>网络接口层：为网络层提供链路级别传输的服务，负责在以太网、WIFI下传输数据包，借助于MAC头，来表示设备，通过ARP协议解析。</p>
</blockquote>
<h3><span id="链接到显示的执行过程">链接到显示的执行过程？</span></h3><blockquote>
<p>首先是解析URL，生成HTTP请求报文，之后经过DNS解析域名查询域名所对应的IP地址，之后通过进行TCP三次握手建立连接，生成TCP报文进行网络传输，之后通过IP协议寻址和路由找到需要传输到的目标服务器，加上IP头再加上MAC头进行以太网下的传输，之后经过网卡、交换机和路由器到达服务器，服务器进行拆包，返回响应报文到客户端。</p>
</blockquote>
<h3><span id="http基本概念">HTTP基本概念？</span></h3><h4><span id="http是什么">HTTP是什么？</span></h4><blockquote>
<p>HTTP即超文本传输协议，是一种应用层的协议，确定了计算机之间交流通信的一种规范。是一种专门在两点之间传输文字、图片、视频等超文本数据的约定和规范。</p>
</blockquote>
<h4><span id="http常见的状态码">HTTP常见的状态码？</span></h4><blockquote>
<p>1开头表示正在处理</p>
<p>2开头表示请求被成功处理</p>
<p>3开头表示重定向</p>
<p>4开头表示客户端错误，请求有误，400表示报文错误，401表示未授权用户访问授权资源，404表示资源未找到，403表示禁止访问</p>
<p>5开头是服务端出错，500，502表示服务端错误响应</p>
</blockquote>
<h4><span id="http常见字段">HTTP常见字段</span></h4><blockquote>
<p>host：服务器主机域名</p>
<p>Content-Length：返回响应长度</p>
<p>Connection：用于建立长连接，保持连接</p>
<p>Content-Type：服务端指定返回的数据格式</p>
<p>Accept：客户端接收的数据格式</p>
<p>Accept-Encoding：接收的压缩格式</p>
<p>Content-Encoding：服务端的压缩格式</p>
<p>Referer：从哪个界面过来</p>
<p>User-Agent：浏览器信息</p>
<p>Authorization：认证信息</p>
<p>Cookie</p>
</blockquote>
<h3><span id="get和post的区别">Get和Post的区别？</span></h3><blockquote>
<p>从用处来看，Get通常用于获取或查询资源，Post用于创建或修改资源。</p>
<p>从幂等性来看，get多次请求不会改变资源的状态，所以是幂等的，可以被缓存，而post用于改变资源，是不幂等的，不适合被缓存。</p>
<p>Get请求一般在url处明文传参，不安全且受浏览器限制，而post的参数是在请求体中，相对较安全而且没有长度限制。</p>
<p>Http协议都是不安全的，Get更容易导致敏感资源泄露。</p>
</blockquote>
<h3><span id="http缓存">HTTP缓存？</span></h3><blockquote>
<p>为了减少HTTP请求次数，进行了HTTP缓存，分为强制缓存和协商缓存，强制缓存取决于浏览器，第一次请求时会到服务器得到资源保存在本地，之后的请求都从缓存中获取数据，过期的话就重新请求，协商缓存则是服务器告诉浏览器要不要使用本地缓存。</p>
</blockquote>
<h3><span id="http协议的优点">HTTP协议的优点？</span></h3><blockquote>
<p>简单灵活速度快，跨平台和易扩展。</p>
<p>HTTP采用header和body的形式，易于理解，并且方便开发人员自定义和修改，易于扩展，另外http的应用非常广泛，天然跨平台。</p>
</blockquote>
<h3><span id="http协议缺点">HTTP协议缺点？</span></h3><blockquote>
<p>双刃剑：无状态、明文传输。缺点：不安全</p>
<p>无状态有好处也有坏处，好处就是服务器不需要记忆HTTP的状态，减轻服务器的负担，但是也是由于无状态，在一些关联性操作时就会很麻烦，比如登录加购物车和下单，每次都要知道用户身份，为解决无状态，可以使用Cookie、Session或者其他方式。</p>
<p>明文传输进行抓包后方便观看，易于我们进行调试，但是数据没有隐私。</p>
<p>不安全就表现在明文传输和无法保证报文完整性等方面。</p>
</blockquote>
<h3><span id="http11vshttp10">HTTP1.1VSHTTP1.0</span></h3><blockquote>
<p>HTTP1.0默认是短连接，HTTP1.1为了减少TCP握手的次数，采用长连接的方式</p>
<p>HTTP1.1新增了很多的状态码，比如100表示正在处理，206范围请求。</p>
<p>HTTP1.1新增了Host字段，HTTP1.1引入了更多的缓存策略</p>
</blockquote>
<h3><span id="http11性能">HTTP1.1性能？</span></h3><blockquote>
<p>HTTP是基于TCP和IP协议的，为了减少TCP握手连接，提出了长连接的通信方式，可以减少TCP创建和销毁的开销。可以进行管道传输，但是也会造成队头阻塞，性能一般般，后面的HTTP可以提高性能。</p>
</blockquote>
<h3><span id="https">HTTPS？</span></h3><blockquote>
<p>HTTPS是HTTP的加强安全版本，基于HTTP协议，以TCP作为底层协议，额外使用SSL/TLS协议用作加密和安全验证，默认端口443。</p>
</blockquote>
<h3><span id="http和https的区别">HTTP和HTTPS的区别？</span></h3><blockquote>
<p>HTTP是明文传输，是不安全的，HTTPS在TCP和HTTP之间加入了SSL/TSL加密协议保证了加密传输。</p>
<p>HTTP建立简单，经过三次握手即可，而HTTPS还需要SSL/TSL握手，才可以进行加密报文传输。</p>
<p>HTTP默认端口是80，HTTPS默认端口443</p>
<p>HTTPS需要CA证书，保证服务器身份</p>
</blockquote>
<h3><span id="https安全实现">HTTPS安全实现</span></h3><blockquote>
<p>HTTPS是安全的，主要原因是在TCP和HTTP之间加了SSL/TSL协议进行信息加密来保证加密传输，防止被窃听，对于数据的加密是对称加密，对于密钥的加密是非对称加密，采用的是私钥加密公钥解密的方式，保证数据不被篡改，另外通过CA进行数字签名，保证证书不被伪造</p>
</blockquote>
<h3><span id="tcp三次握手">TCP三次握手？</span></h3><blockquote>
<p>客户端与服务端建立连接需要经过三次握手。</p>
<p>第一次是客户端向服务端请求SYN连接</p>
<p>第二次是服务端接收到请求，向客户端发送SYN和ACK确认数据包</p>
<p>第三次是客户端发送ACK数据包</p>
<p>三次握手的目的是保证客户端和服务端都有一接一收，即双方都保证对方可以接收和发送。</p>
<p>第一次握手服务端确认了客户端发送正常，第二次握手客户端确认了自己发送和接收正常，并且服务端发送和接收正常，第三次握手服务端知道了客户端和自己发送正常，接收也正常。</p>
<p>三次握手缺一不可。</p>
</blockquote>
<h2><span id="mysql">MYSQL</span></h2><h3><span id="sql篇">SQL篇</span></h3><h4><span id="ddl">DDL</span></h4><blockquote>
<p>用于操纵数据库表和库</p>
</blockquote>
<h5><span id="数据库操作">数据库操作</span></h5><blockquote>
<p>show databases;查看所有数据库</p>
<p>select database();查看当前数据库</p>
<p>create database if not exists film;查看</p>
<p>use film;使用数据库</p>
<p>drop database if exists film;删除数据库</p>
</blockquote>
<h5><span id="数据表操作">数据表操作</span></h5><blockquote>
<p>create table user(id int not null,age int not null)comment ‘用户表’;新建表</p>
<p>drop table user;删除表</p>
<p>show tables;展示所有表</p>
<p>desc user;查看表结构</p>
<p>show create table user;查看建表语句</p>
<p>alter table user add/modify/change/drop/rename to 新增字段/修改字段类型/修改字段/删除字段/重命名字段</p>
</blockquote>
<h4><span id="dml增删改">DML增删改</span></h4><blockquote>
<p>insert into user (id,age) values (1,20),(2,30);</p>
<p>update user set age=20 where id=1;</p>
<p>delete from user where id=2;</p>
</blockquote>
<h4><span id="dcl">DCL</span></h4><blockquote>
<p>权限控制，用户管理</p>
<p>select * from user；</p>
<p>create user ‘ptsnake‘@’localhost’ identify by ‘123456’</p>
<p>alter user ‘ptsnake‘@’localhost’ identify with mysql_native_password by ‘123’;</p>
<p>drop user ‘ptsnake‘@’localhost’;</p>
<p>show grants for ‘ptsnake‘@’localhost’;</p>
<p>grant 权限 on ‘ptsnake’.* to ‘ptsnake‘@’%’授权</p>
<p>revoke all on ‘ptsnake’.* from ‘ptsnake‘@’%’;撤权</p>
</blockquote>
<h4><span id="dql">DQL</span></h4><blockquote>
<p>聚合函数：max，min，count，avg，sum</p>
<p>函数：</p>
<p>字符串函数：concat(‘hello’,’world’)、lower(‘Hello’)、upper(‘hello’)、lpad(‘01’,5,’-‘)、rpad(‘01’,5,’-‘)、trim(‘   Hello ‘)、 substring(s,1,3)</p>
<p>数值函数：ceil(1.1)向上取整 floor(1.1)向下取整 mod(7,3)取余 rand()0-1随机整数、round保留小数</p>
<p>日期函数: curdate() 当前日期 curtime()当前时间 now() year() month() day() datediff(curdate,empdate)算日期差、dateadd(now(),interval 70 day)推迟时间</p>
<p>流程控制函数：case when then else end、if、ifnull</p>
</blockquote>
<h4><span id="约束">约束</span></h4><blockquote>
<p>create table user(</p>
<p>​    id int primary key not null auto_increment,</p>
<p>​    age int not null check(age&gt;0&amp;&amp;age&lt;=120),</p>
<p>​    status char(1) default ‘1’,</p>
<p>​    gender char(1) check(gender=’男’||gender=’女’)</p>
<p>​    constraint fk_id foreign key (dept_id) references dept(id)</p>
<p>)</p>
<p>not null 非空约束 unique 唯一约束 primary key主键约束 default 默认约束 check 检查约束 foreign key 外键约束</p>
</blockquote>
<h4><span id="手撕sql">手撕sql</span></h4><ul>
<li><p>行转列问题</p>
<blockquote>
<img src="/2023/08/01/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/image-20230905201738532.png" alt="image-20230905201738532" style="zoom:80%;"> 

<p>这是行转列问题，需要使用union select</p>
<p>select product_id,’store1’ as store,store1 as price from Products where store1 is not null</p>
<p>union all</p>
<p>select product_id,’store2’ as store,store2 as price from Products where store2 is not null</p>
<p>union all</p>
<p>select product_id,’store3’ as store,store3 as price from Products where store3 is not null</p>
</blockquote>
</li>
<li><p>求第二大</p>
<blockquote>
<p>思路：排除第一大那就是第二大</p>
<p><img src="/2023/08/01/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/image-20230905203905402.png" alt="image-20230905203905402"> </p>
<p>select max(salary) as SecondHighestSalary from Employee where salary!=(select max(salary) as max_salary from Employee) order by salary desc limit 0,1 </p>
</blockquote>
</li>
<li></li>
</ul>
<h3><span id="基础篇">基础篇</span></h3><h4><span id="什么是元组-码-候选码-主码-外码-主属性-非主属性">什么是元组, 码, 候选码, 主码, 外码, 主属性, 非主属性？</span></h4><blockquote>
<p>元组指的是行，码指的是列，候选码指的是某个属性或者属性组可以标识一个元组，主码指的是主键，候选码中的属性称为主属性，其他的是非主属性。</p>
</blockquote>
<h4><span id="数据库三范式了解吗">数据库三范式了解吗？</span></h4><blockquote>
<p>范式是对我们数据库创建的一种规范。</p>
<p>一范式指的是不可再分割</p>
<p>二范式解决了非主属性对主属性的部分依赖</p>
<p>三范式解决了传递依赖问题，符合三范式的数据库系统较好的缓解了数据冗余和插入以及删除时的异常问题</p>
</blockquote>
<h4><span id="主键和外键">主键和外键？</span></h4><blockquote>
<p>主键用于唯一表示一个元组，不可重复，一张表只能有一个主键。</p>
<p>外键用于和其他表建立连接，可以重复，可以有多个外键。</p>
</blockquote>
<h4><span id="为什么不建议使用外键和级联">为什么不建议使用外键和级联？</span></h4><blockquote>
<p>在我们的实际开发中是不建议使用外键和级联更新的，而是在应用层用代码去维护这种逻辑上的关联关系，使用外键它虽然会增强我们数据库的安全性和数据的一致性，但不适合分布式高并发场景，会导致阻塞问题以及影响数据库的插入速度，引入主键之后，增加了我们业务逻辑的复杂性，在增删改时都要考虑到外键的影响，也会因为外键导致失败。在没有分库分表或者并发量不高时可以使用外键和级联来保证数据的完整性和一致性。</p>
</blockquote>
<h4><span id="什么是存储过程">什么是存储过程？</span></h4><blockquote>
<p>类似于平时使用的方法，是一些SQL语句的集合，当我们的操作比较重复时，可以使用存储过程来进行代码复用，保证我们下次复用时的快速调用。但是存储过程我们是应该强力禁止使用的，因为它是非常难以调试的，当我们需要去修改业务时，还要去修改存储过程的话是非常痛苦的，出现问题也难以排查。</p>
</blockquote>
<h4><span id="drop-delete-与-truncate-区别">drop、delete 与 truncate 区别？</span></h4><blockquote>
<p>drop用于删除表，delete用于删除数据，truncate用于清空数据。drop是DDL语言，而delete和truncate是DML语言。</p>
</blockquote>
<h4><span id="char和varchar的区别">char和varchar的区别？</span></h4><blockquote>
<p>char是定长字符串，varchar是不定长字符串，char的效率要比varchar高一点，char存储英文字母是1字节，汉字是2字节，varchar存储都是2字节。对于经常需要改变的，可以使用char，对于定长的可以使用char</p>
</blockquote>
<h4><span id="存储md5应该使用char还是varchar">存储md5应该使用char还是varchar？</span></h4><blockquote>
<p>应该使用char，因为char是定长的字符串，而md5也是定长的，所以用char存储比较合适，而且char是定长的，所以它在改变时不会修改长度，效率比varchar更高一点。</p>
</blockquote>
<h4><span id="为什么不要使用join连接多表">为什么不要使用join连接多表？</span></h4><blockquote>
<p>每进行一次多表连接都会消耗一定的计算资源和内存资源，而且会产生临时表存在缓存中，给缓存带来很大压力，影响查询效率。</p>
</blockquote>
<h4><span id="程序设计分为几步">程序设计分为几步？</span></h4><blockquote>
<p>程序设计分为：</p>
<p>需求分析、概念结构设计、逻辑结构设计、物理结构设计、数据库实施和数据库的运行和维护</p>
</blockquote>
<h4><span id="什么是关系型数据库">什么是关系型数据库？</span></h4><blockquote>
<p>建立在关系模型上的数据库就是关系型数据库</p>
</blockquote>
<h4><span id="decimal-和-floatdouble-的区别是什么">decimal 和 float/double 的区别是什么？</span></h4><pre><code>&gt; decimal是定点数，float和double是浮点数，在计算机中，用二进制表示数字会有精度损失，可以使用decimal去存储有精度要求的小数
</code></pre>
<h4><span id="为什么不推荐使用text和blob">为什么不推荐使用text和blob？</span></h4><pre><code>&gt; 二者不能有默认值，效率比较低，创建索引时要指定前缀索引，消耗大量的网络和磁盘i。
</code></pre>
<h4><span id="datetime和timestamp的区别">datetime和timestamp的区别？</span></h4><pre><code>&gt; datetime是不带时区信息的，timestamp是和时区有关的，timestamp占4字节，datetime占8字节，timestamp表示的时间范围比较小
</code></pre>
<h4><span id="null和的区别">null和’’的区别？</span></h4><pre><code>&gt; null表示不确定的值，即便是两个null，也不是相等的，在实验distinct时又认为是相等的，null会影响聚合函数的结果，查询null必须使用isnull或者isnotnull判断，不能使用比较运算符。
</code></pre>
<h3><span id="索引篇">索引篇</span></h3><h4><span id="什么是索引">什么是索引？</span></h4><blockquote>
<p>索引时一种帮助我们快速检索数据的一种数据结构，它存在于存储引擎层中，根据数据结构的类型可以分为：B+树索引、哈希索引、全文索引，B+树索引是目前用的最多的索引结构，innodb、myisam和memory都支持，全文索引只有myisam和mysql5.6之后支持，哈希索引只有memory比较支持。</p>
</blockquote>
<h4><span id="索引的优缺点">索引的优缺点？</span></h4><blockquote>
<p>使用索引能够高效快速的检索数据，避免了全表扫描。</p>
<p>但是索引也有缺点，表现在时间和空间两个层面，创建索引之后，在对表进行增删改时可能会发生页分离、数据移动和树的调整，需要存储引擎付出额外的时间去维护索引的结构，空间上表现在，索引是使用物理文件存储的，要耗费磁盘空间。</p>
</blockquote>
<h4><span id="innodb和myisam的索引实现机制有什么不同">Innodb和Myisam的索引实现机制有什么不同？</span></h4><blockquote>
<p>innodb是当期数据库版本默认的存储引擎，myisam是之前数据库的默认存储引擎，在索引机制上，二者也有所不同。</p>
<p>innodb中有唯一的聚簇索引，其他的是非聚簇索引，myisam全都是非聚簇索引。innodb和myisam中存储的内容不同，innodb的聚簇索引叶子节点存储的是整行完整记录，非聚簇索引存储的是主键id，myisam的非聚簇索引存储的是地址，innodb的数据和索引存在一个文件中，数据文件就是索引文件，myisam数据文件和索引文件是分开的，索引文件中只存储地址值，innodb要求必须有主键，即便没有也会自动生成，myisam没有要求。</p>
</blockquote>
<h4><span id="一个表如果没有创建索引会生成b树吗">一个表如果没有创建索引，会生成b+树吗？</span></h4><blockquote>
<p>会的，因为innodb会自动给我们创建基于主键的聚簇索引，自动生成b+树，即便没有主键，也会自动选择具有唯一约束的字段作为索引，如果找不到这样的字段，会自动帮我们生成rowid辅助查找。</p>
</blockquote>
<h4><span id="为什么不使用hash索引">为什么不使用hash索引？</span></h4><blockquote>
<p>hash索引不支持范围和顺序查询，只能单值快速查找。</p>
</blockquote>
<h4><span id="二叉查找树-红黑树-平衡二叉树-b树-b-树的区别">二叉查找树、红黑树、平衡二叉树、B树、B+ 树的区别？</span></h4><blockquote>
<p>二叉查找树是一种方便查找的二叉树，比跟结点小的都在左子树，大的都在右子树，可以实现快速查找，但是其本身是二叉树，所以每个结点可以存放的元素个数是有限的，就会导致树的层级很深，不利于大数据量查找，而且如果是顺序插入的话会退化成一种链表，导致层级过深，平衡二叉树是一种特殊的二叉查找树，采用左旋和右旋的方式解决左右子树不平衡的问题，避免了退化成链表，但是依然是二叉树，在数据量过大时层级过深，红黑树是一种符合红黑规则的树，也是一种平衡树，但是他减少了左旋和右旋的次数，同样是二叉树，不适合做索引，B数和B+树是多路复用的树，每一个结点都可以放多个元素，这样在大数据量的情况下就会从瘦高变成矮胖，树的层级降低，方便快速查找，B树和B+树的主要区别在于：B+树的非叶子结点只存放索引，所有结点都会出现在叶子结点中，而B树的叶子结点和非叶子结点都存放的是数据，这就导致B+树每个非叶子结点中可以存放更多的索引，树的层级比B树低，而且B+树的叶子结点之间形成双向循环链表，方便范围查询，提供了查询的稳定性和速度。</p>
</blockquote>
<h4><span id="说一下b树索引的实现原理">说一下B+树索引的实现原理？</span></h4><blockquote>
<p>B+树索引结合了B树和链表的优点，是一种多路复用的树，B+树由一个个的结点组成，每一个结点都输存储引擎中的一页，每个结点上都可以存放多个数据和指针，所以会让树的层级变低，提高查询速度，B+树和B树的重要区别在于B+中非叶子结点只存放索引，所有的非叶子结点也会在叶子结点中出现，数据都存放在叶子结点上，而B树的非叶子结点和叶子结点都存放的是数据，这就导致B+树非叶子结点能存放更多的数据，层级比B树浅，查询速度更快更稳定，另一方面，B+树的叶子结点之间形成双向循环链表，比较支持范围查询和排序。</p>
</blockquote>
<h4><span id="说一下聚簇索引和非聚簇索引的区别">说一下聚簇索引和非聚簇索引的区别？</span></h4><blockquote>
<p>聚簇索引是Innodb根据主键自动为我们生成的一种索引，一张表中只能有一个聚簇索引，而非聚簇索引需要我们去手动创建，一张表中可以有多个聚簇索引，另一方面的话，他们结点存储的数据也是不同的，聚簇索引的叶子结点存放的是数据的完整记录，而非叶子结点存放的是列号和主键索引，非聚簇索引的查询如果不存在覆盖索引的情况的话是需要进行回表查询的。</p>
</blockquote>
<h4><span id="说一下聚簇索引的优缺点">说一下聚簇索引的优缺点？</span></h4><blockquote>
<p>聚簇索引是自动给我们生成的索引，使用聚簇索引可以快速的根据主键进行检索数据，而且聚簇索引是唯一的，进行范围查询和顺序查找是比较快的，但是聚簇索引比较依靠插入顺序，如果不是顺序插入的话可能会导致页分裂现象，而且主键id是不易被修改的，修改的话会导致树的调整。</p>
</blockquote>
<h4><span id="说一下非聚簇索引的优缺点">说一下非聚簇索引的优缺点？</span></h4><blockquote>
<p>非聚簇索引可以帮助我们避免全表扫描，但是如果没有覆盖索引的话需要进行回表查询。</p>
</blockquote>
<h4><span id="说一下b树和b树的区别">说一下B+树和B树的区别？</span></h4><blockquote>
<p>B+树的非叶子结点只存放索引，只起到索引作用，所有的数据都存放在叶子结点，而B树的非叶子结点和叶子结点都存放数据，这就导致B+树能存放更多的数据，层级更浅，另一方面，B+树的叶子结点之间会形成双向循环链表，方便进行排序范围查询。</p>
</blockquote>
<h4><span id="innodb的b树是怎么产生的">Innodb的B+树是怎么产生的？</span></h4><blockquote>
<p>B+树是一种多路复用的树，结合了B树和链表的优点，是由一个个结点组成的，每一个结点都是存储引擎中的一页，每个结点上都可以存放多个数据和指针，这就导致B+树在数据量特别大的情况下依然层级很浅，查询速度很快，非叶子结点不存放数据，只起到索引的作用，所有的数据都存放在叶子结点，所以查询稳定，在叶子结点之间形成双喜循环链表，支持范围查询和排序。</p>
</blockquote>
<h4><span id="计算一个b数能存多少条数据">计算一个B+数能存多少条数据？</span></h4><blockquote>
<p>计算B+树有多少条数据是要根据数据大小来看的，我们知道，B+树中的结点就是存储引擎中的页，默认固定大小是16kb，在B+树中非 叶子结点只存放页号指针和id，假设为10b的话，每一个叶子结点就可以存放1600条索引，假设一条数据占1kb，那么叶子结点中就可以放16条数据，所以如果只有一层，则存放16条数据，2层则存放1600*16，三层则存放1600x1600x16条数据，数据量达到千万级。</p>
</blockquote>
<h4><span id="innodb是怎么支持范围查询的先查位置确定那一页然后利用双向指针进行查询和排序">Innodb是怎么支持范围查询的？（先查位置，确定那一页，然后利用双向指针进行查询和排序）</span></h4><blockquote>
<p>先根据索引查到位置，然后通过双向链表的方式进行查询。</p>
</blockquote>
<h4><span id="为什么要遵循最左前缀原则">为什么要遵循最左前缀原则？</span></h4><blockquote>
<p>在我们使用联合索引时，会根据我们字段的顺序生成B+树，会优先按照字段顺序进行排序，只有前面顺序相同的时候才会比较后面的字段，所以我们不能跳过前面的字段进行查询，不遵循最左前缀原则的话会导致索引失效。</p>
</blockquote>
<h4><span id="范围查找导致索引失效的原理分析">范围查找导致索引失效的原理分析？</span></h4><blockquote>
<p>如果联合索引时，中间字段进行了范围查询，而且是没有等于条件，后面的字段就不会走索引，相当于违背了最左前缀原则</p>
</blockquote>
<h4><span id="索引覆盖的底层原理">索引覆盖的底层原理？</span></h4><blockquote>
<p>索引覆盖的原理是因为根据联合索引查到的数据满足了我们的查询需要，这样我们就不需要去回表进行查询了。</p>
</blockquote>
<h4><span id="索引扫描的底层原理">索引扫描的底层原理？</span></h4><blockquote>
<p>索引扫描是在非聚簇索引上进行扫描，底层是因为双向链表。</p>
</blockquote>
<h4><span id="为什么orderby走索引会失效筛选条件覆盖索引是否超出">为什么orderby走索引会失效？（筛选条件，覆盖索引，是否超出）</span></h4><blockquote>
<p>order by走索引失效的原因有多种，如果非聚簇索引不加where条件的话，并且不存在覆盖索引的话就会不走索引，使索引失效，在mysql中有sort_buffer排序缓存池，先根据筛选条件筛选出要排序的数据，然后判断是否存在覆盖索引，存在覆盖索引则走索引排序，如果不存在则判断字段长度是否超出阈值，如果超出则走双路排序，没有超出则是单路排序。</p>
</blockquote>
<h4><span id="mysql的类型转换有什么要注意的">MYSQL的类型转换有什么要注意的？</span></h4><blockquote>
<p>字符串都会转为0，所以当我们索引字段是字符串时不能拿一个数字和它比较，否则需要整个b+树都转换才行，这样是不走索引的。</p>
</blockquote>
<h4><span id="类型转换导致索引失效原理">类型转换导致索引失效原理？</span></h4><blockquote>
<p>如上，就是因为索引类型是不能进行转换的，如果所以比较不了。</p>
</blockquote>
<h4><span id="什么是索引下推">什么是索引下推？</span></h4><blockquote>
<p>索引下推是mysql的一种优化，可以减少回表次数，我们没有索引下推时，使用聚合索引，会先找到第一个元素匹配的，回表到server层中，然后判断第二个字段是否满足，如果满足则保留，否则则抛弃，使用索引下推之后这些比较都会在索引上完成之后再回表。</p>
</blockquote>
<h4><span id="什么是自适应哈希索引">什么是自适应哈希索引？</span></h4><blockquote>
<p>自适应哈希索引是innodb存储引擎中，为了提高效率，多次查询的数据会在bufferpool上加上一层哈希索引，使innodb也有了hash索引的特性。</p>
</blockquote>
<h4><span id="索引一定能提高效率吗">索引一定能提高效率吗？</span></h4><blockquote>
<p>不一定，索引适用于数据量比较大的情况，数据量小的时候，数据库会认为还不如全表扫描快，而且使用索引的话需要存储引擎花额外的时间来维护索引结构，比如在增删改时可能会导致数据移动和树的改变，比较影响增删改的速度，而且，如果使用了唯一索引，会在增加数据准确判断该数据是否存在了，会影响一定效率，不过是支持使用唯一索引的。</p>
</blockquote>
<h4><span id="非聚簇索引一定会回表吗">非聚簇索引一定会回表吗？</span></h4><blockquote>
<p>不一定，如果发生了覆盖索引，则不需要回表。</p>
</blockquote>
<h4><span id="索引失效情况">索引失效情况？</span></h4><blockquote>
<ul>
<li>使用！=或者&lt;&gt;</li>
<li>进行了like左模糊或者全模糊</li>
<li>被数据库优化器认为不如全表扫描</li>
<li>不符合最左前缀原则</li>
<li>参与了运算</li>
<li>进行isnotnull判断时，如果非空很多，则不走索引，而是全表扫描</li>
</ul>
</blockquote>
<h4><span id="使用索引排序的流程">使用索引排序的流程？</span></h4><blockquote>
<p>在mysql中有排序缓冲区，在排序时会先经过条件筛选得到需要排序的数据，然后判断是否存在覆盖索引，如果有覆盖索引则走索引排序，如果不存在索引排序，则走文件排序。</p>
</blockquote>
<h3><span id="事务篇">事务篇</span></h3><h4><span id="什么是事务谈谈对事务的了解">什么是事务，谈谈对事务的了解？</span></h4><blockquote>
<p>事务是mysql中的基本工作单元，是一组操作的集合，要么都执行要么都不执行。</p>
</blockquote>
<h4><span id="acid特性分别是怎么实现的">ACID特性分别是怎么实现的？</span></h4><blockquote>
<p>A：原子性 C：一致性 I：隔离性 D：持久性</p>
<p>原子性是undolog回滚日志实现的，保证失败回滚</p>
<p>一致性是最终目的，是原子性和隔离性和持久性的结合</p>
<p>隔离性是通过MVCC+锁的方式实现的</p>
<p>持久性是通过redolog重做日志实现的，进行的修改会现在bufferpoll中更新，变成脏页，然后在脏页刷盘时先记录到redolog日志，再去写到文件系统中，这样保证了断电或宕机也能恢复数据，保证了更改的数据是一定会保存的。</p>
</blockquote>
<h4><span id="并发事务的问题">并发事务的问题？</span></h4><blockquote>
<p>并发事务的问题主要表现在：</p>
<p>脏读：脏读是指一个事务读取到另外一个事务修改但未提交的数据</p>
<p>不可重复读：不可重复读是指，一个事务在多次读取同一条数据时，出现的不一致的情况</p>
<p>幻读：幻读是指在一个事务多次读取结果集时，其他线程做出了增加和删除操作，导致结果集不一致</p>
<p>修改丢失：修改丢失是指两个事务同时进行修改时会有一个线程的修改丢失。</p>
</blockquote>
<h4><span id="不可重复读和幻读的区别">不可重复读和幻读的区别？</span></h4><blockquote>
<p>不可重复读更倾向于记录的改变，前后记录结果不一致，一般是修改操作</p>
<p>幻读一般是增删操作，前后的结果集或者数据总数不一致</p>
</blockquote>
<h4><span id="有几个事务隔离级别">有几个事务隔离级别？</span></h4><blockquote>
<p>事务的隔离级别分为</p>
<p>读未提交、读已提交、可重复读、串行化</p>
</blockquote>
<h4><span id="并发事务的控制方式有哪些">并发事务的控制方式有哪些？</span></h4><blockquote>
<p>并发事务的控制包括MVCC并发版本控制和锁。</p>
<p>通过加锁的方式保证写操作的隔离性</p>
<p>通过MVCC保证读操作的隔离性</p>
</blockquote>
<h4><span id="mvcc内部细节">MVCC内部细节？</span></h4><blockquote>
<p>MVCC的实现是依靠三个隐藏字段和readview快照来实现的。</p>
<p>在字段中会有三个隐藏字段，分别记录隐藏rowid、事务id、undolog版本指针，在我们每次进行修改时，都会产生undolog版本修改，类似于头插法插入，形成版本链，而我们的readview呢是一种快照机制，当我们进行非锁定读的时候就会产生快照，上面记录了当前事务id，最小事务id，下一次事务id和当前活跃列表，进行可见性分析，这样就避免了脏读，而我们的RC隔离级别下是每次非锁定读都会产生快照的，而RR隔离级别是第一次非锁定读才会产生readview，这样解决了不可重复读问题，而且通过快照读的方式也一定解决了非锁定读下的幻读问题，锁定读的幻读需要靠临键锁来实现。</p>
</blockquote>
<h4><span id="隔离级别是怎么实现的怎么解决的脏读不可重复读和幻读">隔离级别是怎么实现的，怎么解决的脏读，不可重复读和幻读？</span></h4><blockquote>
<p>隔离级别是MVCC+锁来实现的，脏读是MVCC快照进行可见性分析，保证读已提交，不可重复读是因为RR隔离级别下只会生成一次快照。幻读的解决需要看MVCC和临键锁。</p>
</blockquote>
<h3><span id="内部结构篇">内部结构篇</span></h3><h4><span id="说一下内部结构吧">说一下内部结构吧？</span></h4><blockquote>
<p>mysql的内部结构大概由几部分组成，首先是连接层，用于进行各种工具和语言的数据库连接，内部还有SQL接口，语法解析器，预处理器，查询优化器，查询缓存/缓冲，以及存储引擎层和文件层。</p>
</blockquote>
<h4><span id="说一下sql查询的执行过程">说一下SQL查询的执行过程？</span></h4><blockquote>
<p> 开启了缓存的话先去缓存中找，如果缓存命中则直接返回，返回不能命中，则通过语法解析器解析生成解析树交给预处理器，之后经过查询优化器优化生成查询计划到存储引擎中运行。</p>
</blockquote>
<h4><span id="存储引擎有哪些默认的是什么">存储引擎有哪些，默认的是什么？</span></h4><blockquote>
<p>现在常见的存储引擎包括Innodb、Myisam、Memory，当前默认为Innodb、之前是Myisam。</p>
<p>区别在于Innodb支持事务外键行级锁，对数据的一致性和完整性有较高的保证。</p>
<p>存储引擎的选取一般都是选择Innodb，除非业务有特定要求，对数据一致性和完整性要求不高，读操作比较多时，可以使用Myisam。</p>
</blockquote>
<h4><span id="说说存储引擎架构">说说存储引擎架构？</span></h4><blockquote>
<p>之前有了解过Innodb的存储引擎，看过结构图，大致上分为内存结构和磁盘结构，磁盘结构上主要是表空间和redolog文件，内存结构则有BufferPool、changebuffer和logbuffer，在bufferpool上也会生成一层自适应哈希，查询到的页数据存放在bufferpool，进行数据更改则在changebuffer。Bufferpool中缓存数据页索引页以及undolog页以及插入缓存页等等</p>
</blockquote>
<h3><span id="锁篇">锁篇</span></h3><h4><span id="什么是锁">什么是锁？</span></h4><blockquote>
<p>锁是指的是用来实现并发事务之间隔离性的重要手段。</p>
</blockquote>
<h4><span id="锁有哪几种都是干什么的">锁有哪几种？都是干什么的？</span></h4><blockquote>
<p>锁包括全局锁、行级锁、表级锁。</p>
<p>表级锁中包括：表锁、元数据锁、意向锁和自增锁。</p>
<p>行级锁包括：行锁、间隙锁、临键锁。</p>
<p>表锁用于锁住整表，如果是共享锁，则其他事务依旧可以读取，如果是互斥锁，其他事务不可读取。</p>
<p>元数据锁是自动生成的锁，用于解决DQL、DML语句和DDL的冲突，即对数据的增删改查属于共享锁，对表结构和库结构进行修改的DDL语句属于互斥锁。</p>
<p>意向锁用于解决行锁和表锁的冲突，即如果存在select 。。。。in share mode则会加意向共享锁，此时不可加独占表锁，如果是update和insert和delete语句，则会加意向排他锁，不可加读锁和写锁。</p>
<p>自增锁时锁的特殊一种，在设置自增时，会将自增锁记录在表结构中，和事务是否提交无关，只要有插入就自增。</p>
<p>行记录锁锁记录，间隙锁锁间隙，临键锁锁记录和间隙。</p>
</blockquote>
<h4><span id="表级锁和行锁有了解吗有什么区别">表级锁和行锁有了解吗？有什么区别？</span></h4><blockquote>
<p>锁的粒度不同，锁表和锁行。</p>
</blockquote>
<h4><span id="行级锁的使用注意事项">行级锁的使用注意事项？</span></h4><h4><span id="介绍一下间隙锁">介绍一下间隙锁？</span></h4><h4><span id="行锁是怎么实现的">行锁是怎么实现的？</span></h4><h4><span id="发生死锁的情况">发生死锁的情况？</span></h4><h4><span id="解决死锁的办法">解决死锁的办法？</span></h4><h4><span id="mysql是怎么加锁的">mysql是怎么加锁的？</span></h4><blockquote>
<p>主键索引时：</p>
<p>如果是等值匹配，值存在，则加行记录锁</p>
<p>如果等值匹配，值不存在，在加间隙锁</p>
<p>如果是范围查询，如果大于，则全都加临键锁</p>
<p>如果大于等于，则等于的地方加记录锁</p>
<p>如果是小于，若存在，则前面加临建锁，最后加间隙锁</p>
<p>若不存在，之前加临键锁，下一个加间隙锁</p>
<p>如果是小于等于，存在则所有加临键锁</p>
<p>不存在和加临键锁，后一位加间隙锁</p>
</blockquote>
<h3><span id="日志篇">日志篇</span></h3><h4><span id="慢查询日志如何优化">慢查询日志如何优化？</span></h4><blockquote>
<p>开启慢查询日志之后我们去看一下哪些SQL是查询速度比较慢的，然后进行分析导致查询速度慢的原因，主要原因是两个方面，可能是对锁的等待时间过长，也可能是SQL设计的问题导致查询过慢，做优化的时候应该优先考虑高并发执行的SQL，因为并发下的SQL问题会影响用户体验，也会导致一些问题。然后判断是不是索引失效或者是我们的带宽或者cpu限制导致的过慢，通过explain去查看执行情况。</p>
</blockquote>
<h4><span id="binlog和redolog的区别">binlog和redolog的区别？</span></h4><blockquote>
<p>binlog和redolog都是mysql中记录操作的日志，其中redolog主要是保证了我们事务的持久性，也可以进行一些断电恢复，binlog是归档日志，由于数据备份和数据同步。binlog是逻辑日志，是语句级别的，redolog是物理日志，发生在存储引擎中。</p>
</blockquote>
<h3><span id="sql优化">SQL优化</span></h3><h4><span id="怎么进行sql优化">怎么进行SQL优化？</span></h4><blockquote>
<p>我们进行SQL优化的目的是提高查询速度，一般的步骤就是定位SQL查询速度慢的地方，然后去分析查询慢的原因，之后进行相应的优化，一般的解决方案是加索引的方式来解决，如果数据量过大，则需要通过分库分表的方式来进行，还可以通过读写分离来减轻读写压力。尽量减少查询数据列。</p>
</blockquote>
<h2><span id="spring-ssm-springboot">Spring、SSM、SpringBoot</span></h2><h3><span id="说说对spring的了解">说说对Spring的了解？</span></h3><blockquote>
<p>Spring是一个轻量开源的java框架，开箱即用，能帮助我们简化开发，降低耦合，提高开发效率，他包含了众多模块，核心模块是CoreContainer和AOP，众多模块和功能都是基于AOP和IOC的。</p>
<p>IOC即控制反转，是一种面向对象的设计思想，将创建对象的控制权交给第三方容器，依次达到降低对象之间依赖关系，降低耦合度的效果。</p>
<p>DI即依赖注入，Spring以依赖注入的方式实现了IOC思想，在容器中建立联系，对他们绑定依赖关系。</p>
<p>AOP即面向切面编程思想，将众多业务的交叉功能提取为一个切面，利用动态代理的方式去创建代理对象，在不改变原有业务逻辑的基础上进行功能的增强。</p>
</blockquote>
<h3><span id="说一下对spring容器的了解">说一下对Spring容器的了解？</span></h3><blockquote>
<p>Spring提供了BeanFactory和ApplicationContext两种容器。</p>
<p>BeanFactory是Spring的底层api，是早期的IOC容器，默认采用的是延迟加载的方式加载bean，只有第一次需要使用bean时才会创建bean，所以相对来说，容器的资源要求较低，启动速度较快。</p>
<p>ApplicationContext是BeanFactory的子接口，对BeanFacTory进行了更多的功能扩展，是相对高级的容器，提供了高级特性，如事件发布，国际化信息支持等，bean的创建时在容器加载时就完成的，所以资源要求相对Beanfactory来说要高一点，启动速度较慢，但运行速度快。</p>
</blockquote>
<h3><span id="说一下对beanfactory的了解">说一下对Beanfactory的了解？</span></h3><blockquote>
<p>BeanFactory是早期的IOC容器，是Spring的底层api，该容器中的bean的加载采用的是延迟加载的策略，所以资源占用较少，启动速度较快。</p>
</blockquote>
<h3><span id="说一下对spring-ioc的理解">说一下对Spring IOC的理解？</span></h3><blockquote>
<p>IOC，即控制反转，是一种设计思想，将创建对象的控制权交给第三方容器，交由容器维护对象之间的关系，降低代码之间的耦合度，Spring采用依赖注入的方式实现控制反转，容器中记录了对象之间的联系，创建的注入方式有两种，分别是构造器注入和setter方法注入。</p>
</blockquote>
<h3><span id="spring是怎么管理bean的">Spring是怎么管理Bean的？</span></h3><blockquote>
<p>Spring是通过IOC容器的方式对bean进行创建和管理，可以通过xml或者注解的方式去实现对bean的配置和管理，使用@ConponmentScan注解可以帮助我们快速扫描到bean的定义，放入BeanDefinitionMap中，使用@Autowired、@Resource注解实现自动装配，使用@Scope注解声明bean的作用域。</p>
</blockquote>
<h3><span id="介绍一下bean的作用域">介绍一下Bean的作用域？</span></h3><blockquote>
<p>在Spring中Bean的作用域默认为singleton单例，我们可以使用scope属性来指定bean的作用域，常见的作用域有：singleton、prototype、request、session，prototype是原型bean，每一次获取bean都是不同的，request是每一次http请求都会有不同的bean，session是一个会话下只有一个bean。</p>
</blockquote>
<h3><span id="spring中两个id相同的bean会报错吗">Spring中两个id相同的bean会报错吗？</span></h3><blockquote>
<p>如果在xml中存在两个相同id的bean，会报错，是在讲配置解析为BeanDefinition的时候报错，因为Spring中的Bean是唯一的，不过如果使用注解的方式指定bean的name的话，是不会报错的，只会使用第一个被标注名字的bean。</p>
</blockquote>
<h3><span id="说一说bean的生命周期说一下bean的创建过程">说一说bean的生命周期？（说一下bean的创建过程）</span></h3><blockquote>
<p>在容器启动后，会通过注解扫描或者xml的方式去找到我们的BeanDefinition，将BeanDefinition放入我们的BeanDefinitionMap中，之后进行bean的生命周期，bean的声明周期大致可以分为实例化、属性注入、初始化、使用bean和销毁bean五个阶段，在实例化阶段会反射调用构造方法去实例化bean，如果有参数的话就进行参数的注入，之后进行依赖注入来进行属性填充，之后进入到初始化阶段，在这之前，如果bean的类实现了aware相关的接口，就会先执行其中的方法，实现bean信息的填充，如果有后置处理器的话，就会先执行后置处理器前初始化方法，然后判断是否实现了Initializingbean的接口，实现的话也要去先其中的方法，之后才是我们自定义的初始化话方法执行（@PostConstructor），然后执行后置处理器的后初始化方法，之后就到了销毁阶段，优先执行disposableBean中的销毁方法，再执行我们自定义的销毁方法（@PreDestroy）。</p>
<p>扫描bean–》放入beandefinitionmap–》遍历实例化–》属性注入–》实现aware接口则执行相关方法–》有后置处理器的前初始化方法就执行前初始化方法–》实现了initializingbean接口则执行其中的初始化方法–》执行自己@PostConstructor注解的初始化方法–》执行后处理器的后初始化方法–》执行disposableBean的销毁方法–》执行自定义的销毁方法（@PreDestroy）</p>
</blockquote>
<h3><span id="spring怎么解决的循环依赖">Spring怎么解决的循环依赖？</span></h3><blockquote>
<p>循环依赖问题指的是我们两个bean对是相互依赖的，Spring解决循环依赖的话是靠的三级缓存，一级缓存的话就是指单例池，里面存放我们已经初始化后的bean，二级缓存则是一个半成品池，其中是已经进行了实例化但是还没有初始化的bean，当发生循环依赖时，我们进行属性注入则是注入的一个半成品，采用这种方式解决循环引用，但是不能解决AOP下的循环引用，所以引入了三级缓存，即提供了一个工厂池，我们AOP代理对象的创建时有两种方式的，一种是后处理器创建，一种就是提前创建，在初始化之前就创建代理对象，放入我们的二级缓存中，这样依赖注入时，就注入代理对象的半成品，等注入完成再放入单例池中。</p>
<p>但是构造器注入和多例模式是不能解决的。</p>
</blockquote>
<h3><span id="beanfactory和factorybean的区别">BeanFactory和FactoryBean的区别？</span></h3><blockquote>
<p>一个是bean工厂，是创建和管理bean的容器，是Spring的底层接口，FactoryBean是工厂bean，我们可以使用实例工厂方式来创建我们的bean。</p>
</blockquote>
<h3><span id="autowired和resource的区别">@Autowired和@Resource的区别？</span></h3><blockquote>
<p>这两个注解都可以用于自动装配，不同的是，Autowired注解是类型优先，如果有多个类型则按bean名称装配，而Resource是名称优先，在没有指定name属性时是按名字装配的，如果没有该名称的bean，则按类型装配，一旦指定name，则按名称装配，@resource是java中的注解，Autowired是Spring中的注解。 </p>
</blockquote>
<h3><span id="spring的单例bean是线程安全的吗">Spring的单例bean是线程安全的吗？</span></h3><blockquote>
<p>Spring的默认bean是单例的，如果bean是无状态的，那么就是线程安全的，如果是有状态，有可以被定义的属性，那么就是无状态的。要保证bean是线程安全的，可以考虑更改bean的作用域，设置bean为无状态的，或者采用ThreadLocal的方式对状态数据进行线程隔离。或者采用加锁的方式</p>
</blockquote>
<h3><span id="说一说对aop的理解">说一说对AOP的理解？</span></h3><blockquote>
<p>AOP是Spring的核心模块，AOP即面向切面编程思想，是OOP思想的一种补充，它将众多业务交叉的功能提取出来，作为切面，通过动态代理的方式去给目标对象创建代理对象bean，在不改变原本代码的前提下对业务功能进行增强，达到扩展代码，降低耦合的目的。</p>
<p>AOP术语：连接点，切入点，通知，目标对象，切面。</p>
<p>Spring AOP对AOP的实现有两种方式，如果目标对象实现了某个接口，则会去使用JDK代理去创建代理对象，如果没有实现接口，就不能创建代理对象，此时使用Cglib代理去创建一个目标对象的子类。</p>
</blockquote>
<h3><span id="springaop和aspectj-aop的区别">SpringAOP和AspectJ AOP的区别？</span></h3><pre><code>&gt; Spring AOP是Spring对AspectJ AOP借鉴的产物，属于运行时增强，AspectJ是编译时增强，AspectJ是基于字节码的，在编译阶段就进行增强，SpringAOP则是基于代理的，AspectJ相较于SpringAop功能更加强大，但是SpringAop实现相对比较简单。
</code></pre>
<h3><span id="springaop的实现方式">SpringAOP的实现方式？</span></h3><blockquote>
<p>SpringAop的实现有两种方式，一种是JDK代理，是Java提供的动态代理技术，在运行时创建接口，它要求目标类必须是实现了某个接口，另一种是CGLIB代理，采用的是字节码技术，在运行时创建目标类的子类的代理，当不存在接口时就是使用的这种方式。</p>
</blockquote>
<h3><span id="aop的应用场景">AOP的应用场景？</span></h3><blockquote>
<p>AOP将功能抽取出来作为切面，在上面可以进行对方法增强，可以帮助我们实现一些多个方法的共有功能，比如说可以用于记录日志，用于参数修改，比如我们业务中修改和新增功能是需要记录修改人和修改时间的，如果我们在业务中每次都重复写业务，那是很麻烦的，所以就可以使用aop将这些提取出来，利用动态代理和反射进行参数的更改，另外，Spring的事务功能也是基于AOP和数据库事务的。</p>
</blockquote>
<h3><span id="springaop不能对那些类进行增强">SpringAOP不能对那些类进行增强？</span></h3><blockquote>
<p>只能对Bean生效，对于不受IOC容器管理的对象不生效，CGLIB采用动态代理创建子类的方式生成代理对象，所以对于final修饰的类不能生效。</p>
</blockquote>
<h3><span id="jdk代理和cglib的区别">JDK代理和CGLIB的区别？</span></h3><blockquote>
<p>JDK动态代理是java提供的动态代理技术，在运行时创建接口的代理对象，要求目标对象必须实现接口。CGLIB则是基于字节码技术的，在没有实现接口时，回去创建目标对象的子类，并生成代理对象。</p>
</blockquote>
<h3><span id="有了cglib为什么还要使用jdk动态代理呢">有了CGLIB，为什么还要使用JDK动态代理呢？</span></h3><blockquote>
<p>在性能方面，CGLIB创建的代理对象性能更好，但是花费的时间也更多，对于无序频繁创建的单例bean，使用CGLIB更好，对于多例的bean，则需要频繁创建对象，JDK更好一点。</p>
</blockquote>
<h3><span id="aop的通知类型有哪些">AOP的通知类型有哪些？</span></h3><blockquote>
<ul>
<li>Before：目标对象方法调用前（前置通知）</li>
<li>After：目标对象方法调用后（后置通知）</li>
<li>Around：拿到目标对象，在目标对象前后使用（环绕通知）</li>
<li>AfterRunning：返回结果后执行（返回通知）</li>
<li>AfterThrowing：抛出异常时执行（异常通知）</li>
</ul>
</blockquote>
<h3><span id="怎么定义切面的优先级">怎么定义切面的优先级？</span></h3><blockquote>
<p>使用Order注解或者实现Ordered接口</p>
</blockquote>
<h3><span id="spring事务机制">Spring事务机制？</span></h3><blockquote>
<p>Spring事务是基于数据库事务和AOP来实现的，对于标记了@Transactional注解的方法所属类，SpringAOP会创建一个代理对象，当调用这些方法时，会进行数据库连接，禁用数据库的事务自动提交，然后执行我们方法中的SQL，没有异常则提交，有异常就根据rollbackfor进行回滚，Spring事务隔离级别和MYSQL一致。</p>
</blockquote>
<h3><span id="spring如何管理事务">Spring如何管理事务？</span></h3><blockquote>
<p>Spring支持两种事务编程模型，分别是编程式事务和声明式事务，编程式事务的话是我们通过硬编码的方式去实现事务的管理，需要我们去按照Spring提供的模板来手动管理事务，开发中很少用。声明式事务即在xml中或使用注解@Transactional进行配置，是通过AOP进行的实现，非常方便进行事务管理。</p>
<p>不过有些公司是不允许使用声明式事务的，因为如果在业务时间比较长的时候会出现长事务的情况，导致锁一直被占有，业务一直无法推进，当事务嵌套的时候就容易出现事务混乱的情况，如果项目比较复杂，则不好用注解管理。</p>
</blockquote>
<h3><span id="spring的事务传播方式有哪些">Spring的事务传播方式有哪些？</span></h3><blockquote>
<p>当我们的事务中调用了其他事务方法时，我们就需要使用事务传播机制来约束我们的传播方式，传播方式有Required，这也是默认的传播方式，即当前有事务则加入事务，当前没有事务则新建事务，还有Required_NEW，这种方式是不管有无事务都新建事务，将当前事务挂起，NESTED，这种传播方式是当前有事务则新建一个当前事务的嵌套事务，没有事务的话就会新建事务，还有就是mandatory强制事务，当前有事务则加入，没有事务则抛出异常，还有的话就是supports，notsupported，never，这些传播机制会让事务不会发生回滚，supports是只有事务则加入，没有事务则以非事务方式运行，notsupported是指，以非事务的方式运行，有事务则挂起，never是指以非事务方式运行，有事务则抛出异常。</p>
</blockquote>
<h3><span id="spring事务和分布式事务的区别">Spring事务和分布式事务的区别？</span></h3><blockquote>
<p>Spring事务本质上是利用了AOP和数据库事务，是对数据库事务的一个封装，让我们更好的去使用事务，去满足ACID，而分布式事务则是用于解决多个数据库的情况下的数据一致性问题。</p>
</blockquote>
<h3><span id="transactionalrollbackfor-exceptionclass注解了解吗">@Transactional(rollbackFor = Exception.class)注解了解吗？</span></h3><blockquote>
<p>我们的事务默认是在出现ERROR和运行时异常的时候进行回滚，也就意味着，如果抛出了其他异常，事务可能不会回滚，我们使用事务的rollbackfor属性对事务的回滚异常进行指定，这样在无论是运行时异常还是非运行时异常都会导致事务回滚，保证我们的数据一致性。</p>
</blockquote>
<h3><span id="什么是mvc">什么是MVC？</span></h3><blockquote>
<p>MVC是一种设计模式，将软件分为三层，分别是Model、View、Controller，Model代表数据，View代表视图，Controller代表控制器即处理逻辑，采用分层的方式降低代码的耦合度，便于代码的维护。</p>
</blockquote>
<h3><span id="dao层是用来做什么的">Dao层是用来做什么的？</span></h3><blockquote>
<p>Dao层即持久层，是数据访问层，在项目中作为独立的一层专门用于访问数据库。</p>
</blockquote>
<h3><span id="说说对springmvc的理解">说说对SpringMVC的理解？</span></h3><blockquote>
<p>SpringMVC是Spring的一部分，是Spring中Web应用的解决方案，是一种表现层技术，不同于传统的MVC开发，SpringMVC对于MVC的实现更加灵活便捷，开发效率更高，降低了代码耦合度，减少了大量重复代码的书写。</p>
</blockquote>
<h3><span id="介绍一下springmvc的工作流程">介绍一下SpringMVC的工作流程？</span></h3><blockquote>
<p>浏览器发送请求到服务器上，DispatcherServlet接收请求，然后根据HandlerMapping映射器去寻找响应的Handler，将Handler处理器和拦截器一并返回给DispatcherServlet，之后DispatcherServlet通过HandlerAdapter适配器利用反射的方式调用处理器方法，在方法调用之前还需要对参数进行解析处理，方法执行后产生的ModelAndView交给DispatcherServlet，DispatcherServlet将ModelAndView交给视图解析器解析返回给浏览器，但是实际上我们已经很少使用ModelAndView了，我们通过给Handler加@ResponseBody注解，就可以将返回结果转为json字符串传给前端，这个过程是靠HttpMessageConvert转换器实现的。</p>
</blockquote>
<h3><span id="说一下springmvc的核心组件">说一下springMvc的核心组件？</span></h3><blockquote>
<p>一方面的话，是DispatcherServlet核心处理器，用于接收请求和分发请求和返回响应，还有就是HandlerMapping映射器，用于映射到响应的Handler处理器，HandlerAdapter是执行者，用于封装执行Handler，Handler即处理器，被RequestMapping标注的可以理解为handler。</p>
</blockquote>
<h3><span id="说一说知道的springmvc的注解">说一说知道的SpringMVC的注解？</span></h3><blockquote>
<p>@RequestMapping 用于标注Handler处理器，将处理器方法映射到url，@RequestBody，用于接收post放在请求体中的数据，@RequestParam 用于接收请求参数进行绑定，@PathVariable用于绑定url后的占位符。</p>
</blockquote>
<h3><span id="介绍一下springmvc拦截器">介绍一下SpringMVC拦截器？</span></h3><blockquote>
<p>拦截器会对处理器进行拦截，来增强处理器的功能，常用于身份校验，实现拦截器需要实现HandlerInterceptor接口，实现其中的prehandle（用于处理器执行前），posthandle（用于处理器执行后）和afterCompletion（视图返回后）方法。之后定义配置类实现WebMVCConfigure接口，注册我们的拦截器。</p>
</blockquote>
<h3><span id="过滤器和拦截器的区别">过滤器和拦截器的区别？</span></h3><blockquote>
<p>过滤器即Filter，拦截器是我们SpringMvc中的一个概念，一方面，他们的作用顺序不同，Filter作用于Servlet调用之前，而拦截器是DispatcherServlet被调用之后，响应之前，Filter依赖于Servlet容器，而Interceptor不依赖于Servlet，另一方面，Filter只能处理request和response，而Interceptor可以处理handler，ModelAndView。</p>
</blockquote>
<h3><span id="怎么做统一异常处理">怎么做统一异常处理？</span></h3><blockquote>
<p>在我们实际开发中，需要做全局异常处理，实现全局异常处理要结合@ControllerAdvice和@ExceptionHandler来使用，实际上也是通过AOP来实现的，将处理器织入我们的异常处理AOP中，当抛出异常时交由被@ExceptionHandler标注的方法进行处理。</p>
</blockquote>
<h3><span id="springboot常用注解">SpringBoot常用注解？</span></h3><blockquote>
<p>@SpringBootApplication ：标注在我们的启动类上，由三个注解组成，分别是@SpringBootConfigure、@EnableAutoConfiguration、@ConponmentScan。</p>
<p>bean相关注解：@Conponent、@Service、@Controller、@Mapper、@Repository、@Import、@Configuration、@Scope、@Autowired、@Resource。</p>
<p>请求方式相关注解：Rest风格的几种注解，GETMapping、DeleteMapping。。。。。</p>
<p>传值注解：@RequestBody@RequestParam@PathVariable</p>
<p>读取配置信息：@Value、@ConfigurationProperties、@PropertySource</p>
<p>全局异常处理：@ControllerAdvice、@ExceptionHandler</p>
<p>事务：@Transactional</p>
</blockquote>
<h3><span id="谈谈对springboot的理解">谈谈对SpringBoot的理解？</span></h3><blockquote>
<p>SpringBoot是Spring提供给我们的一种快速工具包，可以帮助我们快速的整合Spring和SpringMVC，采用习惯大于配置的思想，给我们提供了起步依赖和自动配置的功能，大大降低了配置难度，提高了开发效率，而且会帮助我们去进行依赖管理，不需要我们去手动调包，这一点是很节省时间的。</p>
</blockquote>
<h3><span id="springboot中的starter有什么作用">SpringBoot中的starter有什么作用？</span></h3><blockquote>
<p>SpringBoot提供了众多的起步依赖，starte本质上是一个Maven项目对象模型，里面定义了其他的传递依赖，降低了项目依赖的复杂度，我们只需要导入起步依赖就能顺带导入其他的相关依赖，大大降低了配置难度。</p>
</blockquote>
<h3><span id="spring中conditional的作用">Spring中Conditional的作用？</span></h3><blockquote>
<p>在我们自动配置时，这个注解用于判断bean是否需要被加载到IOC容器中，我们可以通过继承Conditional注解来进行一些自己的判断逻辑，不过，SpringBoot为我们提供了很多Conditional注解，用于判断是否需要加载。</p>
</blockquote>
<h3><span id="springboot的起步流程">SpringBoot的起步流程？</span></h3><blockquote>
<p>SpringBoot项目构建完成后产生一个Application入口类，项目启动时会先调用Application中的run方法，进行SpringApplication的实例化操作，再调用另一个run方法去完成这个项目的初始化和启动。在run阶段主要进行了获取监听器和参数配置、打印banner信息、创建并初始化容器、监听器发送通知。</p>
</blockquote>
<h3><span id="描述一下自动配置原理">描述一下自动配置原理？</span></h3><blockquote>
<p>SpringBoot的实现依靠了starter起步依赖和几个相关注解，在我们得到入口类上使用了@SpringBootApplication注解标识了我们是一个SpringBoot过程，实际上该注解主要由三个注解组成，SpringBootConfiguration内部就是一个configuration，标志这也是一个配置类，ConponentScan用于注解扫描，EnableAutoConfiguration是开启自动配置的关键，内部使用了Import注解，传入了一个AutoConfigurationImportSelector类，其中调用了selectImports获取到starter包下的spring.factories中的自动配置类的全包名，里面是一个个被Bean注解的类，所以相关的依赖都会被自动配置到Spring容器中。</p>
</blockquote>
<h3><span id="怎么解决springboot中的跨域问题">怎么解决SpringBoot中的跨域问题？</span></h3><blockquote>
<p>由于浏览器的同源策略，浏览器JavaScript只能访问同源的资源，而不能跨域访问，我们要解决跨域就要在保证安全的基础上保证可以访问，可以使用CORS实现，在配置类中实现WebMvcConfigure接口，重写addCorsMapping方法来注册谁可以跨域访问</p>
</blockquote>
<h3><span id="和的区别">#{}和${}的区别？</span></h3><blockquote>
<p>#{}是预编译的，是参数占位符，mybatis会将#{}替换为？，在参数注入时会整体加单引号，有效避免了SQL注入，${}是进行SQL的拼接，是静态文本替换，会有SQL注入的风险</p>
</blockquote>
<h3><span id="xml-映射文件中除了常见的-select-insert-update-delete-标签之外还有哪些标签">xml 映射文件中，除了常见的 select、insert、update、delete 标签之外，还有哪些标签？</span></h3><blockquote>
<p>还有<set><where><foreach><if><trim>等，还有<sql><include><selectkey>等</selectkey></include></sql></trim></if></foreach></where></set></p>
</blockquote>
<h3><span id="mybatis的优缺点">Mybatis的优缺点？</span></h3><blockquote>
<p> Mybatis是基于SQL语句编程的，比较灵活，不会对我们的应用程序和数据库设计造成影响，SQL写在xml中降低了代码的耦合度，支持动态sql，底层是基于jdbc的，所以兼容各种数据库，开发时比较简洁的，节省了很多没必要的jdbc代码，能与spring集成，缺点是SQL的编写量较大，比较依靠程序员的SQL功底，SQL语句是依赖于数据库的，就导致移植性没有很好，不能随便更改数据库。</p>
</blockquote>
<h3><span id="xml-映射文件中除了常见的-select-insert-update-delete-标签之外还有哪些标签">xml 映射文件中，除了常见的 select、insert、update、delete 标签之外，还有哪些标签？</span></h3><blockquote>
<p>还有很多动态sql的标签，比如set、where、if、when、foreach、sql、include这些标签，还有requestmap自定义影视和cache等标签。</p>
</blockquote>
<h3><span id="dao的工作原理是什么dao中的方法可以重载吗">Dao的工作原理是什么？Dao中的方法可以重载吗？</span></h3><blockquote>
<p>Dao层主要用于数据库访问，Dao接口时没有实现类的，mybatis是采用的动态代理的方式将映射文件和接口绑定，创建代理类，通过接口全类名和方法名来找到对应的MappedStatment对象，Dao层中的方法是可以重载的，但是对应的xml中只能有一个id。</p>
<p>Dao 接口的工作原理是 JDK 动态代理，MyBatis 运行时会使用 JDK 动态代理为 Dao 接口生成代理 proxy 对象，代理对象 proxy 会拦截接口方法，转而执行 <code>MappedStatement</code> 所代表的 sql，然后将 sql 执行结果返回。</p>
</blockquote>
<h3><span id="如何进行主键回填">如何进行主键回填？</span></h3><blockquote>
<p>xml中将useGenerateKeys设置为true，将keyProperty设置为id</p>
</blockquote>
<h2><span id="redis">Redis</span></h2><h3><span id="什么是redis">什么是Redis？</span></h3><blockquote>
<p>Redis是一种基于内存的非关系型数据库，对于数据的读写都是在内存中完成的，而且是非关系型数据库，不存储关系，所以读写速度非常快，常用于做缓存、消息队列和分布式锁等场景。还提供了多种数据类型来应对不同的场景，对数据类型的操作都是原子性的，而且redis还支持事务、持久化、Lua脚本、集群。</p>
</blockquote>
<h3><span id="redis快的原因">Redis快的原因？</span></h3><blockquote>
<p>不同于关系型数据库</p>
<p>Redis是基于内存的，不是磁盘IO，访问速度非常快。</p>
<p>Redis不存储关系，仅存储数据。</p>
<p>Redis中有多种优化过的数据结构，性能较高。</p>
<p>Redis对键值对的读写是单线程的，没有线程切换的开销    </p>
</blockquote>
<h3><span id="redis和memcached的区别">Redis和Memcached的区别？</span></h3><blockquote>
<p>他们都是基于内存的，都可以做缓存，性能都比较高。</p>
<p>但是Redis的数据类型更丰富，Redis支持数据持久化，Memcached会因为断电重启等原因失效。</p>
<p>Redis支持集群，Lua脚本、发布/订阅模型、事务等功能，Memcached不具有。</p>
</blockquote>
<h3><span id="为什么使用redis做缓存">为什么使用Redis做缓存？</span></h3><blockquote>
<p>Redis是基于内存的非关系型数据库，所有的读写操作都是基于内存的，而且是非关系型数据库，只存储数据，不存储关系，所以，Redis的性能是非常快的，而且Redis对多种场景提供了不同的数据类型供我们选择，而且Redis每秒钟能处理的请求数非常高，QBS非常高，能轻松到10W+，能承受高并发场景下的高请求数量。</p>
</blockquote>
<h3><span id="redis特征">Redis特征</span></h3><blockquote>
<p>采用键值对存储</p>
<p>数据之间没有关联</p>
<p>内部采用单线程</p>
<p>性能较高</p>
<p>多数据类型支持</p>
<p>持久化支持</p>
</blockquote>
<h3><span id="为什么要使用redis">为什么要使用Redis？</span></h3><blockquote>
<p>如果所有请求都交给mysql的话，一方面，mysql是磁盘IO，性能较低，速度较慢，而且会给数据库带来巨大压力，所以对于一些高频热点数据我们就需要使用redis做缓存，查询先存缓存中查，来提高我们系统的性能。Redis的QBS可以达到10w+每秒，大大提高了我们系统的整体并发性。</p>
</blockquote>
<h3><span id="redis数据类型">Redis数据类型</span></h3><blockquote>
<p>Redis对于不同的场景需求，给我们提供了不同的数据类型。</p>
<p>基本数据类型包括：</p>
<ul>
<li>String 可以用于缓存对象、做计数器、简单限流、做共享session、分布式锁。</li>
<li>List 是双向链表，用于做消息队列、做动态列表。（消息队列有问题，不能回复，需要自己设id，并且不支持多消费者。）</li>
<li>Hash 可用于缓存对象、做购物车，不同于String的对象存储，虽然Hash的所占空间更大，但是可以对字段进行很好的修改。</li>
<li>Set 类似于HashSet，可用于求并集、差集、交集的场景，比如求共同关注、好友推荐等，还可以用于一些去重的场景，比如点赞列表，还可以做一下随机类型的场景，比如随机推送、随机抽奖。</li>
<li>Zset 类似于TreeSet 可用于做各种排行榜</li>
</ul>
<p>其他补充类型有</p>
<ul>
<li>BitMap：用于二值统计场景，比如签到，用户登录状态校验，连续签到统计总数等场景</li>
<li>GEO 基于sorted_set，用于位置信息的场景，比如附近位置，求距离，滴滴打车，商铺位置筛选。</li>
<li>HyperLogLog 用于大数据下的基数统计，比如百万级别的UV统计</li>
<li>Stream 是Redis提供的消息队列，会自动生成全局唯一id，支持消费者组。</li>
</ul>
</blockquote>
<h3><span id="五种基本类型的底层实现">五种基本类型的底层实现</span></h3><blockquote>
<p>String底层是SDS，是Redis自己实现的一种简单动态字符串，支持存储二进制、整数、浮点数和图片等，是二进制安全的。</p>
<p>List底层是双向链表或压缩列表，不过现在都是使用的quicklist了</p>
</blockquote>
<h3><span id="redis中如何用跳表来存储的">redis中如何用跳表来存储的？</span></h3><blockquote>
<p>我们的zset实际上就用到了跳表，跳表就是将有序链表变成了一种类似于二分查找的形式，可以进行快速的查找和增删操作。</p>
</blockquote>
<h3><span id="删除key会阻塞redis吗">删除key会阻塞redis吗？</span></h3><blockquote>
<p>会，我们对键值对的读写操作都是单线程的，删除string的时间复杂度为O1，删除其他类型的时间复杂度为On，如果元素数量太多，则可能导致阻塞，如果string太大，也会导致阻塞。</p>
</blockquote>
<h3><span id="string的应用场景有哪些">String的应用场景有哪些？</span></h3><blockquote>
<p>String 是最常用的一种类型，是一种安全的简单动态字符串，可以存储图片、字符串、整数、浮点数等，可以用于缓存对象、计数器实现、简单限流、共享session、分布式锁。</p>
</blockquote>
<h3><span id="string存储对象好还是hash存储对象好">String存储对象好还是Hash存储对象好？</span></h3><blockquote>
<p>我们可以采用String存储序列化之后的对象，不能修改字段信息，hash是可以对对象的字段进行单独存储，可以修改或添加字段。</p>
<p>他们两个都可以用于存储对象，我们需要结合业务场景来看，如果是需要频繁修改字段信息，就比较适合用hash，其他场景用String更好，因为String消耗的内存只有hash的一般，并且可以嵌套存储对象。</p>
</blockquote>
<h3><span id="string的底层实现是什么">String的底层实现是什么？</span></h3><blockquote>
<p>String的底层实现并不是C语言，而是Redis自己实现的一种SDS简单动态字符串，它是一种二进制安全的字符串，相比于C语言中字符串，SDS是可以动态扩容的，所以不会存在缓冲区溢出问题，另一方面，C语言获取字符串长度的时间复杂度为On，而SDS的时间复杂度为O(1)，而且SDS是二进制安全的，可以用于存储图片、二进制文件等。</p>
</blockquote>
<h3><span id="购物车信息用hash存储好还是string">购物车信息用Hash存储好还是String？</span></h3><blockquote>
<p>这种场景下，使用Hash更好，一方面，可以让用户id作为key，商品id作为filed，数量作为value，是天然匹配购物车的，而且购物车是需要对字段频繁修改的，使用hash更好一点，在购物车场景下，使用hash对数量的增减和对购物车总数的统计以及对购物车清除的操作都是有命令对应的，比较好实现。</p>
</blockquote>
<h3><span id="使用redis实现排行榜怎么做">使用Redis实现排行榜怎么做？</span></h3><blockquote>
<p>可以使用Sorted_set，实现各种排行榜功能。</p>
</blockquote>
<h3><span id="set的应用场景是什么">Set的应用场景是什么？</span></h3><blockquote>
<p>Set有点类似于HashSet，可以用于求交集并集差集的场景，比如共同关注、好友推荐等功能，也适用于随机场景，比如随机推送、随机抽奖、随机点名，还可以用于一些去重场景，比如点赞功能</p>
</blockquote>
<h3><span id="使用set实现抽奖怎么做">使用Set实现抽奖怎么做？</span></h3><blockquote>
<p>使用sadd key member1 member2 member3来添加参奖人员</p>
<p>如果是不能重复中奖的，就可以使用spop移除一个或多个元素</p>
<p>如果可以重复中奖，则需要使用srangemember 获取到指定数量的元素，不会移除集合，可以重复中奖。</p>
</blockquote>
<h3><span id="使用bitmap统计活跃用户怎么做">使用BitMap统计活跃用户怎么做？</span></h3><blockquote>
<p> BitMap比较适合做二值统计的场景，要统计活跃用户。</p>
<p>统计活跃用户的话，要以天作为key，用户id作为offset偏移量，1标记为活跃</p>
<p>setbit 20200308 3589 1</p>
<p>setbit 20200308  3669 1</p>
<p>setbit 20200309 3589 1</p>
<p>统计活跃就要进行与运算，得到谁连续活跃。</p>
<p>bitop and desk1 20200308 20200309 </p>
<p>统计一共多少用户活跃使用or</p>
<p>bitop or desk2 20200308 20200309</p>
</blockquote>
<h3><span id="使用hyperloglog统计百万uv怎么做">使用HyperLogLog统计百万UV怎么做？</span></h3><blockquote>
<p> 将元素加到HyperLogLog中</p>
<p>pfadd page_1:uv user1 user2 user3</p>
<p>获取到估计的UV</p>
<p>pfcount page_1:uv</p>
</blockquote>
<h3><span id="什么是缓存穿透">什么是缓存穿透？</span></h3><blockquote>
<p>缓存穿透是指，当用户访问数据时，数据即不在缓存中，也不在数据库中，导致了缓存丢失，去访问数据库时也找不到数据进行重新构建缓存，当有大量的这种请求到我们的数据库时，会给数据库带来极大的压力。</p>
<p>造成缓存穿透的场景一般有两种，一种是我们业务发生了误删，导致数据库和redis中都不存在这种数据，另一种情况是黑客的恶意攻击，故意大量访问不存在的业务。</p>
</blockquote>
<h3><span id="缓存穿透怎么解决">缓存穿透怎么解决？</span></h3><blockquote>
<p>解决缓存穿透一般有三种方案，一种是对非法请求进行限制，另一种是缓存空值，还有一种是使用布隆过滤器。</p>
<p>在api接口处对请求访问进行限制，判断参数是否合理、请求参数是否是非法的等等来限制访问。</p>
<p>缓存空值则是针对数据库查询不到的数据，在缓存中缓存一个空值，下次查询从缓存中获取即可，这也是比较常用的手段。</p>
<p>使用布隆过滤器来快速判断数据是否存在，避免通过数据库判断，布隆过滤器的原理是通过不同的hash计算出不同的hash值，然后计算出在hash表中的位置，这样标记处存在的元素，在访问时，只会在redis和布隆过滤器上访问，避免无效数据直接打到数据库的情况。但是布隆过滤器会发生hash冲突，导致一些漏判的情况。布隆过滤器判断数据存在不一定确实存在，但是判断不存在则一定不存在。</p>
</blockquote>
<h3><span id="什么是缓存击穿">什么是缓存击穿？</span></h3><blockquote>
<p> 缓存击穿也可以理解为热点key问题，当某个热点key过期失效时，大量请求继续对key进行访问，这样就会导致大量的请求达到数据库中，这就是缓存击穿，常发生在秒杀场景。</p>
</blockquote>
<h3><span id="什么是缓存雪崩">什么是缓存雪崩？</span></h3><blockquote>
<p> 缓存雪崩是指大面积的缓存同时失效或者Redis宕机的情况，大量的请求打到数据库，导致系统崩溃。</p>
</blockquote>
<h3><span id="怎么解决缓存雪崩">怎么解决缓存雪崩？</span></h3><blockquote>
<p>如果是大面积缓存同时失效的情况，可以采用均匀设置过期时间、互斥锁、设置逻辑过期时间交由业务后台定时更新，如果是Redis宕机的话，就要使用服务熔断和请求限流机制，服务熔断是指所有对于缓存的请求都返回错误，不去mysql中去查找，缓解数据库压力，不过所有业务都无法运行了，我们还可以采用请求限流的方式，只将少部分业务交给数据库处理，等redis恢复再解除限流。还可以构建Redis集群，来避免服务宕机导致的缓存雪崩。</p>
<ul>
<li>均匀设置过期时间，我们应该避免将大量的缓存设置同一个过期时间，而是随机过期时间，保证不会大量缓存同时失效。</li>
<li>设置互斥锁，使用setnx，如果缓存不存在，就获得锁，保证只有一个线程可以访问数据库重建缓存，其他线程进入等待，互斥锁一定要设置超时时间，防止业务出现问题，导致大量线程持续阻塞。</li>
<li>逻辑过期策略，不设置过期时间，而是存储的时候用一个字段表示过期时间，在后台业务进行过期时间的判断，过期则去数据库中查，重新构建缓存。</li>
<li>服务熔断机制，当redis宕机之后，暂停引用对缓存服务的访问，直接返回错误，从根源上避免了缓存雪崩，不过会导致业务瘫痪。</li>
<li>请求限流策略，当宕机的时候，采用限流的方式，只允许少部分请求到达数据库</li>
<li>使用Redis集群技术，避免缓存雪崩。</li>
</ul>
</blockquote>
<h3><span id="怎么解决缓存击穿">怎么解决缓存击穿？</span></h3><blockquote>
<p> 设置互斥锁，后台更新策略。实际上缓存击穿可以看做是缓存雪崩的子集，只不过是热点key失效。</p>
</blockquote>
<p><img src="/2023/08/01/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/image-20230904170519854.png" alt="image-20230904170519854"></p>
<h3><span id="数据库和缓存怎么保证一致性">数据库和缓存怎么保证一致性？</span></h3><blockquote>
<p>应该采用先更新数据库，再删除缓存的策略，这样会保证数据的一致性，只会有短暂的数据不一致情况，但是可能导致缓存未命中的情况发生，所以</p>
</blockquote>
<h3><span id="redis到底是单线程还是多线程的">Redis到底是单线程还是多线程的？</span></h3><blockquote>
<p>Redis的底层依旧是多线程的，我们说redis是单线程的原因是因为，redis在6.0之前网络IO和对键值对的读写是单线程完成的，是并发安全的，6.0之后引入多线程是指网络IO的请求过程变成了多线程，读写依然单线程，实际上redis的单线程是对键值对的读写是单线程的，其他操作比如持久化这些都是多线程的。</p>
</blockquote>
<h3><span id="什么是redis持久化">什么是Redis持久化？</span></h3><blockquote>
<p>Redis是支持持久化的，也就是会将内容保存下来，防止因为Redis宕机或者其他原因导致数据丢失，Redis的持久化是通过AOF日志和RDB快照来实现的。</p>
</blockquote>
<h3><span id="什么是rdb">什么是RDB？</span></h3><blockquote>
<p>RDB是通过创建快照的方式获得到某个时间点的数据副本，将副本压缩备份到RDB磁盘文件中。</p>
<p>RDB提供了save和bgsave来生成RDB文件，save命令是在主线程中生成RDB文件，会阻塞主线程，bgsave则是fork一个子线程，让子线程生成RDB文件，可以避免主线程的阻塞，是默认选项。</p>
</blockquote>
<h3><span id="rdb的流程">RDB的流程？</span></h3><blockquote>
<p>当达到bgsave的要求时，会从主线程fork一个子线程，由子线程读取内存数据，压缩备份RDB文件写入磁盘中，新的RDB文件代替旧的RDB文件，在此过程中，主线程采用写时复制的技术，如果主线程要进行修改缓存，那么会拷贝一份原数据，在新数据上进行修改，读也是在新数据上读。但是会有极端情况，在RDB写入期间，所有的数据都被修改了，这样导致RDB备份的和缓存中的完全不一致。</p>
</blockquote>
<h3><span id="rdb会什么时候执行">RDB会什么时候执行?</span></h3><blockquote>
<p>默认在服务停止的时候会执行一次RDB。</p>
<p>我们也可以自己设置，采用bgsave的方式，设置多少时间内发生多少次修改就执行RDB备份，这个时间不能设置太长，太长会导致时间内宕机导致数据大量丢失，太短则会导致RDB过于频繁，而fork子线程、压缩数据、写入RDB都是比较耗时的。</p>
</blockquote>
<h3><span id="什么是aof">什么是AOF？</span></h3><blockquote>
<p>AOF是Redis中另一种解决持久化的方法，和mysql中的redolog比较相似，是通过追加的方式将执行的命令记录到AOF文件中，appendfsync always是每执行一次写命令就会往AOF文件中写，appendfysnc everysec是将写命令写入缓冲区中，每间隔一秒将缓冲区写入到AOF文件中，最多丢失一秒的数据，是默认方案，appendfysnc no是将写命令放入缓冲区，由操作系统决定何时写回磁盘。</p>
</blockquote>
<h3><span id="aof缺陷">AOF缺陷？</span></h3><blockquote>
<p>AOF文件是追加操作，记录的是命令，所以文件要比RDB文件要大，而且，可能会有无用命令记录，所以需要有AOF重写技术，在redis中是有配置的，当文件增大了一倍时或者体积得到64M时会重写AOF，将重复操作变为一个操作。</p>
</blockquote>
<h3><span id="aof流程">AOF流程？</span></h3><blockquote>
<p>AOF持久化流程大致为：</p>
<ul>
<li>命令追加，将写命令追加到缓冲区中。</li>
<li>文件写入，调用write函数，将缓冲区文件写入系统内核缓冲区中</li>
<li>文件同步，调用fsync进行硬盘同步，保证持久性</li>
<li>文件重写，AOF越来越大时，要对AOF进行重写，压缩文件</li>
<li>重新加载，redis重启时，加载AOF进行数据恢复。</li>
</ul>
</blockquote>
<h3><span id="aof-vs-rdb">AOF VS RDB</span></h3><blockquote>
<ul>
<li>RDB主要是对内存做快照，而AOF是用于记录每一条写命令</li>
<li>RDB是通过fork子线程的方式进行压缩备份RDB文件的，所以会有数据不完整、不一致的问题，AOF相对来说比较完整，最多只会有1s的数据丢失</li>
<li>AOF是记录写命令，RDB是记录内存快照，而且会进行压缩，所以AOF的文件要比RDB大很多。</li>
<li>RDB在数据恢复时比较快，AOF比较慢</li>
<li>RDB和AOF同时存在时，AOF优先级比较高</li>
<li>RDB的fork、压缩和写入等操作比较耗时，对CPU的占有率比较高，AOF是磁盘IO，对CPU占用较少，但是AOF重写也要占用CPU</li>
<li>RDB适合对一致性要求不高，可以容忍几分钟内的数据丢失，启动速度更快，AOF适用于对数据安全要求比较高的场景。</li>
</ul>
</blockquote>
<h3><span id="aof为什么是执行命令之后再记录">AOF为什么是执行命令之后再记录？</span></h3><blockquote>
<p>一方面是为了节省检查开销，AOF不能做语法检查，会直接记录，这是不太合适的</p>
<p>执行完之后再记录就不会阻塞当前线程，但是执行命令刚结束redis就宕机的话会导致数据丢失，而且会阻塞后续线程。</p>
</blockquote>
<h3><span id="aof重写了解吗">AOF重写了解吗？</span></h3><blockquote>
<p>由于AOF是记录的写命令，所以可能会有对相同字段的修改，这些命令在数据恢复时都是无效的，只会让AOF过大。</p>
<p>AOF 重写是指当我们的AOF文件越来越大的时候，我们的redis会自动在子线程中为我们生成一个更小的AOF，我们redis默认会在AOF文件翻倍或者文件大小超过64M的时候进行AOF重写，实现对AOF文件的压缩。</p>
</blockquote>
<h3><span id="持久化的策略怎么选取">持久化的策略怎么选取？</span></h3><blockquote>
<p>RDB是默认的持久化，如果我们能结束几分钟的数据丢失的话可以选择使用这个，如果我们对一致性要求比较高，就要使用AOF，它最多只会丢失1s的数据。也可以采用混合模式，即提高速度又保证完整性，如果在集群下，应尽量在slave进行持久化。</p>
</blockquote>
<h3><span id="主节点宕机导致全部数据丢失">主节点宕机导致全部数据丢失？</span></h3><blockquote>
<p>如果我们主节点不做持久化，而且使用了一些运维根据进行宕机自动重启的话，就会导致哨兵还没有开始执行选取的时候，主节点就重启了，那么重启之后是一个空的，没有数据，而从结点也要从主节点同步，这样就会导致数据全部丢失，导致缓存雪崩。别自动重启，交给哨兵或者集群做故障转移。</p>
</blockquote>
<h3><span id="线上的redis怎么备份">线上的redis怎么备份？</span></h3><blockquote>
<p>可以去设置定时的那种任务，每隔多久就备份到别的机器上一份进行异地容灾。还可以每天都备份一份AOF文件到别的目录。</p>
</blockquote>
<h3><span id="redis集群">Redis集群</span></h3><blockquote>
<p>单点的redis的并发依然是有限的，当我们并发量比较高的时候，就应该去建立集群，只需要在从库上执行slaveof或者replicaof方法即可搭建主从结构，实现读写分离。</p>
</blockquote>
<h3><span id="主从数据一致原理">主从数据一致原理？</span></h3><blockquote>
<p>当我们的并发量比较高的时候，单点的Redis就不够用了，我们就需要搭建主从集群，这样可以读取压力分担到多个从结点中，不过我们需要保证主从结点中的数据一致性。</p>
<p>我们的主从复制可以分为全量同步和增量同步，全量同步发生在第一次slave结点向主库请求同步的时候，增量同步则发生在slave结点宕机或者链接断开的情况。我们每一个结点都会有一个id和一个offset偏移量，当我们第一次请求同步的时候，slave与master主节点进行连接，传递id和offset，master会判断该slave结点的id是否和自己一致，不一致则说明是第一次请求同步，就会生成RDB文件并传输给slave从结点进行执行，这期间如果主节点还有写命令，就会记录在repl_backlog中，和从库建立长链接，将repl_backlog发送给从库去执行，保证了主从一致性。</p>
<p>如果我们从结点宕机或者连接断开的时候，这时候从结点无法同步到数据，再次连接同步的时候，如果还是全量同步的话，会重新创建RDB，这是非常低效的，所以这时候主节点会通过id判断是之前我同步过的子节点，根据offset偏移量来判断repl_backlog中是否还有该偏移量,如果已经被覆盖了，则需要进行全量复制，如果没有被覆盖，则会根据偏移位置向从结点发送repl_backlog，保证主从一致性。</p>
<p>当从结点过多时，为了减轻全量同步对主节点的压力，可以设置中间的slave，作为其他结点的主节点。</p>
</blockquote>
<h3><span id="主从节点之间是长链接还是短连接">主从节点之间是长链接还是短连接？</span></h3><blockquote>
<p>长链接，在同步之后，主从之间会建立长链接，用于将每一次主节点的写命令发送到从节点。</p>
</blockquote>
<h3><span id="主从复制风暴">主从复制风暴？</span></h3><blockquote>
<p>如果是一主多从的情况，当很多slave宕机重启的时候，就要从主节点中疯狂获取RDB文件，这就会影响到主节点的网络IO，造成主从复制风暴。</p>
</blockquote>
<h3><span id="为什么要有哨兵机制哨兵是什么">为什么要有哨兵机制，哨兵是什么？</span></h3><blockquote>
<p>在我们的主从架构中，是读写分离的，如果我们的主节点宕机的话，写入操作就会失败，也无法进行主从同步了，这是不合理的，哨兵机制就可以帮助我们解决这种问题。它可以帮助我们监控主节点是否存活、如果判定为没有存活的话就选取slave子节点作为主节点，之后的数据同步都从新的master中同步，主节点重新启动之后会变为当前节点的从节点、作为客户端的通知来源给客户端推送消息。</p>
<p>监控–》故障转移–》通知</p>
</blockquote>
<h3><span id="怎么判断主节点是不是真正的宕机了">怎么判断主节点是不是真正的宕机了？</span></h3><blockquote>
<p>哨兵会通过心跳机制，每隔一秒进行一次ping，如果超过一定时间主节点没有返回响应，则认为主节点主观下线了，如果超过半数的哨兵没有得到响应，则认定主节点客观下线，这是为了避免因为自身网络问题导致误判。</p>
</blockquote>
<h3><span id="由那个哨兵来进行故障转移呢">由那个哨兵来进行故障转移呢？</span></h3><blockquote>
<p>需要选取哨兵进行故障转移，一般来说是选用第一个认定主管下线的哨兵。</p>
</blockquote>
<h3><span id="为什么哨兵至少设置3个">为什么哨兵至少设置3个？</span></h3><blockquote>
<p>这是因为进行主从切换时要进行选举主节点，必须要超过半数以上才能满足条件，如果只有两个的话，如果有一个宕机了，就会导致选举失败而无法故障转移。</p>
</blockquote>
<h3><span id="故障转移过程">故障转移过程？</span></h3><blockquote>
<ol>
<li>选取新主节点，在从节点中进行选取，首先会排除slave和master断开时间过长的从节点，因为数据太不完整了，然后根据优先级、偏移量、id来进行选取，比较重要的是偏移量，偏移量比较高的就说明数据更完整。</li>
<li>哨兵将选取的从节点变成master</li>
<li>通知其他从节点之后从该主节点中同步数据</li>
<li>最后将主节点标记为slave，再启动时成为该master的slave。</li>
</ol>
</blockquote>
<h3><span id="redis主从是同步复制还是异步复制">redis主从是同步复制，还是异步复制？</span></h3><blockquote>
<p>异步复制，会先记录到repl_backlog buffer中，然后异步发送到从节点。</p>
</blockquote>
<h3><span id="网络抖动导致主从频繁切换">网络抖动导致主从频繁切换？</span></h3><blockquote>
<p>机房网络抖动比较严重的话，我们的心跳机制就可能会一定时间得不到响应，就会重新选举主节点，导致频繁切换，可以设置redis-cluster-timeout来设置时间，如果没有超出时间，则不会重新选举。</p>
</blockquote>
<h3><span id="主从切换导致缓存雪崩">主从切换导致缓存雪崩？</span></h3><blockquote>
<p>这是由于主从节点时区不同，比如主节点大量的key在12：30过期，但是从节点的时区已经到1：00了，如果此时进行主从同步就会导致大量过期数据需要被删除。所以我们要把主从放在同一个时区下，这样还能保证网络稳定。</p>
</blockquote>
<h3><span id="分片集群">分片集群？</span></h3><blockquote>
<p>主从和哨兵能帮助我们解决高可用和高并发读的问题，但是没有解决高并发写的问题，也没有解决海量数据的存储问题。</p>
<p>分片集群特征</p>
<p>集群中有多个master，每个master都保存不同的数据，所以保证海量数据的存储，而且每个master都可以进行写操作，这样就解决了高并发写问题，而且每个master也可以有多个slave，所以也解决了高并发读的问题，master之间进行心跳检测，所以不需要哨兵来监控主节点是否宕机。</p>
</blockquote>
<h3><span id="散列插槽">散列插槽？</span></h3><blockquote>
<p>Redis会将16383个插槽（hash slot）分配给我们的节点，在redis中数据key并不是与节点绑定的，而是和插槽绑定，会根据key的有效部分来计算插槽值，如果key中有{}，则有效值是{}，没有则有效值是整个key。</p>
<p>使用插槽是因为将key和插槽绑定，可以保证不管是节点宕机还是集群伸缩，只需要将插槽转移就可以保证无论如何都可以找到对应的插槽，得到数据。</p>
<p>当我们访问节点的时候会根据key计算插槽，重定向到插槽来获取数据。</p>
</blockquote>
<h3><span id="redis如何判断key在哪个实例">Redis如何判断key在哪个实例？</span></h3><blockquote>
<p>redis会将16383个散列插槽分配给我们的节点，根据key的有效部分计算hash值，对16384取余得到插槽，找到插槽实例。</p>
</blockquote>
<h3><span id="如何将同一类数据固定的保存在同一个redis实例中">如何将同一类数据固定的保存在同一个redis实例中？</span></h3><blockquote>
<p>使用{}，这时候key的有限制是{}部分，得到的hash值是相同的</p>
</blockquote>
<h3><span id="集群伸缩">集群伸缩</span></h3><blockquote>
<p>我们可以添加或删除集群中一个节点，在redis的cluster中有add-node来新增节点，需要指定新节点ip端口和集群的ip和端口。</p>
<p>还可以通过–cluster-slave来设置天生就是从节点，并用–cluster-master-id指定主节点是谁。但是新增的节点没有分配插槽，需要使用reshard给节点重新分配插槽。</p>
</blockquote>
<h3><span id="集群故障转移">集群故障转移</span></h3><blockquote>
<p>自动故障准仪：当某个主节点宕机时，其他master根据心跳检测判断是否宕机，判断为客观下线后就会选举新节点作为主节点，然后给它打上标记，下次恢复时就会变成主节点的slave从节点。这是一个自动的行为。</p>
<p>手动转移：如果我们想要达到机器的更改，进行无感的迁移，就可以手动的执行failover命令，slave就会通知maste拒绝一切请求，将数据同步给slave，之后进行故障转移，slave和master的身份切换。</p>
<p>自动故障转移是防止宕机导致业务进行不下去，手动故障转移则是我们有目的性的做一些迁移。</p>
</blockquote>
<h3><span id="主从vs哨兵vs集群">主从VS哨兵VS集群</span></h3><blockquote>
<p>主从通过设置从结点的方式，来实现读写分离，缓解了我们的读的压力，但是主节点宕机的话就会导致写操作无法执行，并且无法继续进行同步，所以就需要哨兵机制，哨兵的作用就是进行监视我们的主从结点，如果主节点宕机了就会选取一个新的主节点，并让其他从结点从该结点进行同步，通知我们的服务器从哪个结点读写数据，但是哨兵和集群只缓解了读取压力，没有缓解写入压力，所以redis提供了集群模式，就是有多个主节点负责进行写入，采用散列插槽的方式和key进行绑定，不再由哨兵来进行监控，而是多个主节点互相监控，当master宕机时同样会进行故障转移。集群主要解决了高并发写的问题。</p>
</blockquote>
<h3><span id="redis集群是怎么进行分片的">Redis集群是怎么进行分片的？</span></h3><blockquote>
<p>在redis中，key是和散列插槽进行绑定的，会将16384个插槽分给master结点，这样能保证进行故障转移或者集群扩缩的时候，不会导致数据丢失，只需要对插槽进行转移即可，当我们访问数据的时候，根据key的有效位计算出hash值，和插槽数取模得到插槽位置，去相应的分配中去取key值。</p>
</blockquote>
<h3><span id="集群支持批量操作吗">集群支持批量操作吗？</span></h3><blockquote>
<p>支持，但是必须在同一个插槽中，使用hashtag指定。</p>
</blockquote>
<h3><span id="内存回收策略">内存回收策略？</span></h3><blockquote>
<p>redis中有两个内存回收策略，分别是过期删除策略和内存淘汰策略。</p>
</blockquote>
<h3><span id="过期删除策略中redis怎么知道key是否过期">过期删除策略中Redis怎么知道key是否过期?</span></h3><blockquote>
<p>在redis的db结构中，是有两个字典的，一个用来存放所有key-value，一个用于存放标记了存活时间的key和ttl，具体何时删除缓存则是有两种方案，一种是惰性删除，一种是周期删除，惰性删除是指过期的时候不去处理，而是当被访问的时候去检查存活时间，然后进行删除，这样的问题就是当一个key过期了之后一直没有被访问就会导致一直没有被删除，另一种是定期删除，是通过定时任务，周期性的抽样部分的key，判断是否过期，然后执行删除，定期清理又包括slow和fast两种模式，slow默认执行频率为10，执行时间不超过25ms，fast模式执行频率比较高，而且耗时比较少。</p>
</blockquote>
<h3><span id="redis死循环阻塞问题">redis死循环阻塞问题？</span></h3><blockquote>
<p>在redis中，有一个randomkey的指令会随机选取我们的key，但是我们知道我们设置了过期时间的key是不会立即删除的，而且slave是不会自己清理的，只会同步主节点，所以randomkey如果发生在slave中，就会可能一直随机到已经过期的key，不断进行选取，导致死循环问题。在redis5.0之后得到了解决，设置slave最多执行多少次，如果超过次数，无论是否找到都退出。</p>
</blockquote>
<h3><span id="内存淘汰策略">内存淘汰策略？</span></h3><blockquote>
<p>内存淘汰策略是指当redis内存使用达到阈值时，redis会主动挑选部分key进行删除。</p>
<p>redis有八种内存淘汰策略</p>
<ul>
<li>noevicition 即不淘汰任何key，满了就拒绝写入</li>
<li>volatile-ttl 对于设置了超时时间的key，比较key的剩余TTL，TTL最小的最先淘汰</li>
<li>allkeys-random 所有key中随机进行删除</li>
<li>volatile-random 对有过期时间的key进行随机删除</li>
<li>allkeys-lru 对全体key，采用最少最近使用的方式进行删除，即最后一次访问时间越久远就优先删除</li>
<li>volatile-lru 对设置了ttl的key，采用最少最近使用的lru算法进行删除</li>
<li>allkeys-lfu 对全体key，采用最少频率使用的lfu算法进行删除，即统计key的访问频率，频率越小，越先删除。</li>
<li>volatile-lfu 对设置了ttl的key，采用lfu算法进行删除。</li>
</ul>
</blockquote>
<h3><span id="为什么没有设置过期时间redis数据却没有了">为什么没有设置过期时间，redis数据却没有了？</span></h3><blockquote>
<p>在我们的redis有一个maxmemory限定，当我们的内存超过了maxmemory，就会触发内存淘汰策略，根据具体的策略来回收内存，redis中的内存回收策略有8种，分别是大致可以分为不进行数据淘汰和进行数据淘汰两种，默认是不进行数据淘汰，只拒绝写入命令，另外的话还有volatile-ttl对设置过期时间的key选择将要过期的key进行回收，allkeys-random从所有key中随机选取进行回收，volatile-random，从设置过期时间的key中随机删除，allkeys-lru，lru最少最近使用算法进行选取删除，volatile-lru，对有过期时间的key进行lru删除，allkeys-lfu，对所有key按使用频率删除，volatile-lfu，对设置过期时间的key按使用频率进行删除。</p>
</blockquote>
<h3><span id="lru和lfu的区别">LRU和LFU的区别</span></h3><blockquote>
<ul>
<li>LRU是最少最近使用的key会被淘汰，指的是，上一次访问比较久远的key会被优先淘汰。会计算当前时间和上一次访问的时间差作为判断条件</li>
<li>LFU指的是按频率淘汰，会在高位记录时间戳，低位记录逻辑访问频率。</li>
<li>一般来说我们都是使用LRU，最近没有使用的就删除，在存在大量热点数据的时候可以通过LFU估算频次，淘汰频次较低的。</li>
</ul>
</blockquote>
<h3><span id="string">String</span></h3><blockquote>
<p>String是redis最简单也是最常用的数据结构</p>
<p>Redis是C语言写的，但是并没有使用C语言的字符串，而是自己构建了一种动态字符串，保证了二进制安全，不会造成缓冲区溢出，string可以保存字符串、整数、浮点数、图片、序列化对象。</p>
<p>常用命令</p>
<p><img src="/2023/08/01/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/image-20230902163957866.png" alt="image-20230902163957866"></p>
<p>应用场景：</p>
<ul>
<li>需要存储常规数据：比如session、token、图片地址、序列化对象（比hash更节省空间）</li>
<li>需要计数的操作，比如简单的限流、页面单位时间的访问次数，incr，decr，自定义id生成器（可用于分表）</li>
<li>setnx设计分布式锁</li>
<li>setex设置存活时间</li>
</ul>
</blockquote>
<h3><span id="hash">Hash</span></h3><blockquote>
<p>value中存放的是键值对，字符串作为filed，value作为value，比较适合存储对象，可以直接修改某个对象的值，有点类似于HashMap，也是数组加链表表示的hash表</p>
<p>常用命令：</p>
<p><img src="/2023/08/01/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/image-20230902171701564.png" alt="image-20230902171701564"></p>
<p>hash比较适合存储对象，可以对字段值有较好的修改。</p>
<p>常用场景</p>
<p>存储对象信息，比如用户信息、商品信息、电影信息这些一定会被访问的对象信息</p>
<p>可以用于购物车中，hincrby就可以实现购物车中商品数量的加减，hgetall可以实现全选，hlen可以显示购物车有多少个商品。</p>
<p>购物车场景解决方案。</p>
<ul>
<li>将用户id作为key</li>
<li>将商品id作为字段</li>
<li>将商品数量作为value</li>
<li>浏览就是遍历hash，添加商品就是追加新的字段，改变数量就是incrby，删除商品就是清除字段，清空购物车就是删除key</li>
</ul>
</blockquote>
<h3><span id="list">list</span></h3><blockquote>
<p>存储多个数据额，是有顺序的，底层是双向链表</p>
<p>常用命令，rpush，lpush，lrange，llen，lpop，rpop，lindex，lset，lrem，brpop，blpop，可以实现队列，实现栈</p>
<p>应用场景，可以用于推送最新动态、最新文章，也可以实现消息队列，但是效果不好。</p>
<p>可以进行分页第一页的存取、做最新消息的展示，做日志</p>
</blockquote>
<h3><span id="set">set</span></h3><blockquote>
<p> 与hash完全一致，但是仅存储键，值全是nil，值不可重复</p>
<p><img src="/2023/08/01/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/image-20230902185902457.png" alt="image-20230902185902457"></p>
<p>可以用于存放不可重复的信息，比如点赞列表</p>
<p>还可以实现共同关注，共同粉丝，好友推荐，音乐推荐</p>
<p>还可以实现一些随机的业务，比如随机推送，随机点名，随机抽奖</p>
<p>可以做去重，统计有多少用户访问、有多少ip访问，做数据过滤。</p>
<p>封禁ip，进行反爬。</p>
</blockquote>
<h3><span id="sorted_set">sorted_set</span></h3><blockquote>
<p>做排行榜，类似于treeset</p>
<p>常见命令</p>
<p><img src="/2023/08/01/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/image-20230902192240458.png" alt="image-20230902192240458"></p>
<p>需要做排序的就需要使用sorted_set来排序。</p>
</blockquote>
<h3><span id="bitmap">BitMap</span></h3><blockquote>
<p>位图，用于数据量特别大的二值统计场景。</p>
<p>采用命令</p>
<p>setbit key offset value 设置偏移量的位置为0或1</p>
<p>getbit key offset 获取到偏移量对应的值</p>
<p>bitcount key begin end 获取范围内为1 的个数</p>
<p>bitpos 获取首次为1的位置</p>
<p>bitmap的场景</p>
<p>可以用于签到统计这种二值统计场景</p>
<p>比如查看签到了多少天、查看哪天签到哪天没签到，查看首次签到时间，查看登录状态。</p>
</blockquote>
<h3><span id="hyperloglog">HyperLogLog</span></h3><blockquote>
<p>也是一个集合，是一种统计基数的数据结构，简单来说HyperLogLog可以用于提供不精确的大概去重计数，存储大小固定，比较小。只需要12k，就能存储2的64次方的基数。</p>
<p>常用的操作只有</p>
<p>pfadd key element新增元素到集合中</p>
<p>pfcount key返回预估基数</p>
<p>pfmerge destkey sourcekey sourcekey 将集合合并。</p>
<p>常用于百万级大基数的网页UV。</p>
</blockquote>
<h3><span id="geo">GEO</span></h3><blockquote>
<p>用于存储经纬度。</p>
<p>底层是sorted_set，score记录经纬度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 存储指定的地理空间位置，可以将一个或多个经度(longitude)、纬度(latitude)、位置名称(member)添加到指定的 key 中。</span><br><span class="line">GEOADD key longitude latitude member [longitude latitude member ...]</span><br><span class="line"></span><br><span class="line"># 从给定的 key 里返回所有指定名称(member)的位置（经度和纬度），不存在的返回 nil。</span><br><span class="line">GEOPOS key member [member ...]</span><br><span class="line"></span><br><span class="line"># 返回两个给定位置之间的距离。</span><br><span class="line">GEODIST key member1 member2 [m|km|ft|mi]</span><br><span class="line"></span><br><span class="line"># 根据用户给定的经纬度坐标来获取指定范围内的地理位置集合。</span><br><span class="line">GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]</span><br></pre></td></tr></table></figure>

<p>应用场景</p>
<p>打车，店铺位置排序，搜索附近。</p>
</blockquote>
<h3><span id="stream">Stream</span></h3><blockquote>
<p>Redis专门为消息队列设计的数据结构，List做消息队列是有缺陷的，比如不能持久化，不能读取到历史消息，用过一次就销毁了，而且不能重复消费，需要生产者自定义唯一id</p>
</blockquote>
<h2><span id="前端">前端</span></h2><h2><span id="项目">项目</span></h2><h3><span id="filmonline">FilmOnline</span></h3><blockquote>
<p>项目描述：随着网络发展，人们的观影需求也逐日增高，如何更加方便便捷的线上购票和管理影院显得尤为重要，该项目面向影院工作人员和有线上购票需求的消费者，实现线上购票以及医院管理。</p>
<p>项目技术栈：SpringBoot、MybatisPlus、Mysql、Redis、JWT、Vue、ElementUI。</p>
<p>项目功能：登录注册、员工管理、影片管理、电影排片、选座购票、优惠秒杀、评论管理、订单管理、用户管理、放映厅管理、套餐管理。</p>
<p>项目参与情况：</p>
<p>项目初期：参与需求分析、功能分析、数据库结构创建。</p>
<p>功能方面：实现拦截器进行短信登录验证，使用OSS实现文件上传。</p>
<p>业务方面：负责后台管理系统中员工表、电影表、优惠券表的CRUD，使用AOP结合反射实现公共字段填充和日志记录，实现上映日优惠折扣秒杀并排查高并发问题、实现选座购票业务。</p>
</blockquote>
<h4><span id="介绍一下项目">介绍一下项目</span></h4><blockquote>
<p>这个项目算是贯彻了我的大学生涯吧，起初它只是一个静态网页，是我们小组的前端期末作业，当时也不太会java，就用PHP做的一些简单的前后端交互和数据库查询，也是成为了那个学期的优秀项目，之后我们学习了数据库，对数据库的知识有了更多的了解，就重新写了数据库，改了之前的很多命名不规范一些问题，也添了很多的表，到大三的时候学习了javaweb开发和Spring这些java框架，就有了此项目的雏形，分别用servlet和SpringBoot进行了实现，在期末考核中也得到了满分，在实训中也是成为了优秀小组和优秀项目，不过有很多实际问题没有考虑，比如在高并发场景下的读写问题和业务上的并发问题，之后就学习了使用redis做缓存来缓解mysql的压力，来适应高并发场景，也新增了秒杀业务。这也算是在不同的知识水平有不同的思考和实现，与时俱进吧。我很高兴能和大家一起不断的学习，业务的逐渐完善也是让我们获得了更多的成就感。</p>
</blockquote>
<h4><span id="需求分析">需求分析？</span></h4><blockquote>
<p>该项目服务于影院管理用户和具有购票需求的用户，需要有后台管理系统做统计和各种信息管理，另外就需要针对普通用户做前台界面，需要满足基本的电影浏览、选座购票和个人订单管理等需求。</p>
</blockquote>
<h4><span id="功能分析">功能分析？</span></h4><blockquote>
<p>后台进行表管理CRUD、电影排片、秒杀发布、信息统览，前台进行登录注册、查看电影详情，选座购票、优惠券秒杀、点赞评论，个人信息修改，订单管理等功能。</p>
</blockquote>
<h4><span id="短信验证登录的逻辑">短信验证登录的逻辑？</span></h4><blockquote>
<p>短信登录验证和权限校验这方面主要就是靠的三部分，分别是redis来缓存验证码、jwt作为登录令牌、HandlerInterceptor做拦截器进行请求拦截。</p>
<p>登录的时候需要校验手机号、验证码格式，如果验证码正确就生成jwttoken返回给前端，之后的前端每次都携带token来访问我们的服务端，在拦截器中校验解析token，然后将token存放在threadLocal中，以空间换时间的方式来方便我们在多处需要用户信息的时候进行获取。</p>
<p>验证码设置，有效时间为10分钟，发验证码要先看redis中是否有验证码，如果有直接发送验证码，如果没有验证码则创建一个以用户手机号作为key的信息，对发送验证码的请求进行限流，以手机号作为key，设置过期时间为30分钟，期间每次发送验证码都要检查设置自增，如果超过一定值的时候就返回异常提示。</p>
</blockquote>
<h4><span id="请求限流怎么做的">请求限流怎么做的？</span></h4><blockquote>
<p>我们这个项目中是对接口的简单限流，利用了AOP、redis、lua脚本、自定义注解和枚举类。</p>
<p>首先自定义了注解，注解内包含key值，限流时间，限流次数和限流类型，用枚举类来表示限流类型。</p>
<p>写了一个限流的方法类，使用lua脚本，每一次访问都要进行一次incrby，如果次数超出就返回false。</p>
<p>在aop中设置注解切点表达式，使用前置通知，获取到切点上的注解，判断限流类型，如果是对所有用户的限流，则让类名和方法名作为key，如果是手机号的限流，以手机号和类名接口名作为key。如果限流时间内超出次数，就抛出异常。</p>
<p>以发送验证码为例，记录了手机号和类名方法名，每一次发送都自增，如果30分钟内发送验证码超过5次，则抛出异常。</p>
</blockquote>
<h4><span id="项目中都哪些地方用了缓存">项目中都哪些地方用了缓存？</span></h4><blockquote>
<p>很多读操作都用到了缓存，比如电影信息、用户信息、电影点赞信息、以及优惠券等。</p>
<p>全局id自增器、请求限流、消息队列、短信验证码存储、分布式锁。</p>
</blockquote>
<h4><span id="秒杀系统设计">秒杀系统设计</span></h4><blockquote>
<p>秒杀系统的话，它涉及到的问题比较多嘛。</p>
<p>首先的话，在秒杀前会有大量用户到我们的页面中，而这些界面的渲染都是静态的，不会改变，所以如果再直接到服务器上就不太好了，就可以去写静态的秒杀界面，将电影信息直接在界面展示，而不走服务器，尽可能减少服务器压力。</p>
<p>到了秒杀时间后考虑的问题就是怎么去抗高并发，首先就是我们的服务器，要抗住高并发，就应该选择使用高性能服务器比如Nginx，将请求分发到我们的集群tomcat上，然后再做业务，数据的访问并发问题就要通过加redis缓存来降低mysql的压力了，可以设置集群来分担读写压力，也用来防止宕机，必须要进行缓存预热防止缓存雪崩问题导致服务器压力太大，秒杀场景肯定要与数据库交互的，mysql怎么抗住高并发呢，也可以设置集群来分担读写压力、或者采用加分布式锁或者异步下单来缓解数据库压力。</p>
<p>抗住高并发之后要解决的问题就是业务问题，秒杀可能会出现的问题就是超卖问题和一人一单问题。</p>
</blockquote>
<h4><span id="超卖问题怎么解决的">超卖问题怎么解决的？</span></h4><blockquote>
<p>超卖问题的解决思路有多种。</p>
<p>超卖问题本质上还是线程不安全问题，我们平时解决线程不安全问题都是通过加乐观锁或悲观锁的办法，并发场景下加分布式锁会影响性能，所以可以采用乐观锁的方式来解决数据的一致性问题，采用版本号法，只有版本相同时才进行扣减库存，不过超卖问题是在库存扣减完的时候才会出现的，所以完全可以设置库存大于1时才更新库存。</p>
<p>不过这种场景如果在并发量较高时，会给数据库带来很大的压力。</p>
<p>所以可以采用异步秒杀的方式，将库存量放在redis中，用一个set集合来记录抢到优惠券的信息，此时，不再是去数据库中判断库存和进行扣减，会在redis中预减库存和判断是否被下单，加入成功之后就将用户id、优惠券id、订单id放入阻塞阻塞队列或者消息队列中，开启异步线程进行下单操作。</p>
<p>具体操作：创建消费者组，lua脚本判断库存是否充足和是否重复下单，将商品id，用户id和订单id放入消息队列中，然后开启线程池，进行异步的处理消息，处理未被消费的信息，如果出现异常则处理pending-list中未被消费的消息。处理完信息一定要ack确认消息。</p>
</blockquote>
<h4><span id="一人一单问题怎么解决">一人一单问题怎么解决？</span></h4><blockquote>
<p>采用lua脚本判断是否下过单结合分布式锁兜底</p>
</blockquote>
<h4><span id="数据库表创建">数据库表创建</span></h4><blockquote>
<p>前台：</p>
<p>用户表tb_user</p>
<p>用户详情表 tb_user_info</p>
<p>电影表tb_film</p>
<p>优惠券表tb_voucher</p>
<p>秒杀卷表tb_skill_voucher</p>
<p>优惠券订单表 tb_voucher_order    </p>
<p>电影票订单表 tb_ticket_order</p>
<p>场次表 tb_schedule</p>
<p>评论表 tb_evaluation</p>
<p>影厅表 tb_hall、</p>
<p>后台：</p>
<p>员工表 tb_employee</p>
</blockquote>
<h4><span id="实现拦截器登录校验">实现拦截器登录校验</span></h4><blockquote>
<p>使用redis、JWT令牌和Spring的拦截器，实现HandlerInterceptor实现拦截器，再到WebMvcConfigure中注册拦截器。</p>
<p>前台用户登录</p>
<p>业务流程：用户输入手机号，进行发送验证码，先对手机号格式进行校验，校验成功则发送验证码，将验证码保存在redis中，设置超时时间，可以使用setnx，失败则弹出相关警告，超时才可以重发。拿到验证码进行登录，在登录业务中，校验用户名和验证码格式，然后获取redis中的验证码和输入验证码比对，成功则查看该手机号有没有用户，有用户则将用户id存入JWT中返回给前端，之后前端将token保存到本地，然后之后的每次请求都携带请求头来访问，之后设置拦截器，实现HandlerInterceptor接口，重写prehandler和aftercomple，prehandler中获取请求头并用jwt解析，获取到其中的用户id，将其存入到ThreadLocal中，在返回后释放ThreadLocal。</p>
<p>后台登录：根据员工工号和密码进行登录，需要查询到用户的盐值和密码，对工号进行重写加密，比对和数据库中密码是否相同，相同则登录成功，设置JWT，然后通过验证，同样存入到ThreadLocal中。</p>
<p>拦截器中是根据路径拦截的，会判断uri中是否是访问的user下的接口，是的话就判断其中一个token，是admin就判断另一个token并存入另一个ThreadLocal。</p>
</blockquote>
<h4><span id="实现文件上传">实现文件上传</span></h4><blockquote>
<p>使用的Alioss对象存储服务，在配置yml中保存连接的信息，然后读取配置到一个类中进行封装，加上ConfigurationProperties(prefix = “filmonline.alioss”)注解保证可以装配到该类中，并且加上Component，交由容器管理。然后写一个AliOSS的工具类，里面封装了我们的上传操作，之后写配置类，加bean注解，并且将属性类注入。</p>
<p>文件上传需要校验文件格式，校验文件大小，校验文件后缀。</p>
</blockquote>
<h4><span id="员工表crud只有admin有修改和新增以及禁用权限">员工表CRUD（只有admin有修改和新增以及禁用权限）</span></h4><blockquote>
<p>员工表没有和其他表有关联，所以只是单表的CRUD</p>
<p>登录功能：根据员工工号和密码进行登录，需要查询到用户的盐值和密码，对工号进行重写加密，比对和数据库中密码是否相同，相同则登录成功，设置JWT，然后通过验证，同样存入到ThreadLocal中。</p>
<p>员工筛选分页查询：使用的是MybatisPlus中的分页插件，根据传入的页码和大小来进行分页。</p>
<p>根据id查员工，用于修改的时候</p>
<p>修改员工，传入DTO对象，进行修改，使用Mybatis或者MybatisPlus都可以</p>
<p>禁用启用员工账号，就是设置状态为0和1就行了</p>
<p>删除员工，通过工号进行删除</p>
<p>新增员工，传入基本信息，进行新增员工</p>
</blockquote>
<h4><span id="电影表crud">电影表CRUD</span></h4><blockquote>
<p>电影表和订单表有关系，优惠券有关系，和评论表有关系，和场次表有关系</p>
<p>电影表和类型表是关联的</p>
<p>类型表中name有题材、类型、主演</p>
<p>电影表中有类型表，需要进行分步查询，先查类型表，再将电影id对应的类型查出来用List存储，然后将List存入到电影表中。</p>
<p>电影表中和其他表是一对多的关系</p>
<p>电影表的CRUD，包括</p>
<p>电影表多条件分页，查询到电影表进行按条件分页</p>
<p>按id查询电影，需要将电影类型List也传入到返回类VO中</p>
<p>修改电影表信息，需要传入类型完整对象，包括类型List，然后通过类转换去修改电影信息，再去删除所有类型表中数据，再批量插入类型表中。</p>
<p>新增电影表信息，需要传入完整的对象，进行新增和类型表的批量插入。</p>
<p>上架下架：设置status</p>
<p>批量删除电影表信息：对电影表进行批量删除</p>
</blockquote>
<h4><span id="拦截器链设计">拦截器链设计</span></h4><blockquote>
<p>由于需要权限验证，所以需要多个拦截器</p>
<p>首先GloableInteceptor拦截所有，但对部分可以浏览的界面放行，然后到user的拦截器链，拦截user下的所有访问，如果不存在登录信息则返回false，设置返回头401，之后进入admin拦截器链，如果访问了admin下的接口，则拦截判断有没有登录信息，没有登录信息则返回false设置响应头为402，之后进入权限拦截器，如果访问了admin权限的接口，则判断用户是不是admin，不是则不允许访问，设置请求头403。</p>
</blockquote>
<h4><span id="优惠券表的crud">优惠券表的CRUD</span></h4><blockquote>
<p>优惠券表的CRUD</p>
<p>全表分页查询</p>
<p>新增优惠券，设置对应的电影id，优惠券信息，此时使用SQL来进行新增</p>
<p>新增秒杀券，将在秒杀卷中创建后id回传，在优惠券中也创建</p>
<p>修改优惠卷</p>
<p>删除优惠券，同时删除</p>
</blockquote>
<h4><span id="公共字段填充">公共字段填充</span></h4><blockquote>
<p>很多业务需要插入更新时设置创建人、创建时间和修改人、修改时间，这些义务是交叉的，所以可以使用切面的方式将他们提取出来，我们这里是使用枚举类加自定义注解的方式来实现的，在枚举类中定义了UPDATE和INSERT和DELETE，然后自定义了注解，里面写了value，返回类型是枚举类，之后在需要进行增删改的接口上加上枚举类，设置相应的value，我们就可以在AOP中根据切点表达式进行功能增强了，在前置通知中获取到连接点的signature，获取到其中方法上的注解，再获取到注解的枚举类型，获取到连接点的参数然后判断是增加还是修改，进行反射赋值，如果是修改，就反射设置修改人和修改时间，如果是增加就设置创建人，创建时间，修改人和修改时间。</p>
</blockquote>
<h4><span id="日志记录">日志记录</span></h4><blockquote>
<p>通过AOP来记录日志，创建日志表，手写注解，在需要记录日志的方法上加上注解，然后通过切点表达式绑定，在around通知中写日志记录代码，要获取到类名和方法名以及操作者的id和运行时间。然后插入到日志表中。</p>
</blockquote>
<h4><span id="实现优惠券秒杀">实现优惠券秒杀</span></h4><blockquote>
<p>抢购优惠券的逻辑很简单。</p>
<p>会先判断库存够不够，如果库存足够就去扣减库存并且新增秒杀订单。但是高并发场景是会出现问题的，比如出现超卖问题和一人多单的问题。</p>
<p>出现超卖问题：</p>
<p>在多线程情况下，是会有并发安全问题的，当多个用户同时进入线程发现订单库存充足，那么就会导致这几个线程都会扣减库存并且插入到秒杀订单中，就会导致超卖问题，解决超卖问题的话有两种方案，通过加互斥锁或者使用版本号法。</p>
<p>加互斥锁的方式是让其他线程阻塞，自然就不会出现并发问题，但是会导致大量线程陷入阻塞，使并发度降低，影响用户体验，而且互斥锁的话会导致线程频繁上下文切换，影响性能</p>
<p>利用版本号法解决，是一种乐观锁的方式，版本号法指的是每次修改前都会确认一下数据的版本号是否和当前查到的版本号一致，如果一致才更新，这里面我们可以根据库存作为版本，但是在库存充足的时候超卖问题是不会发生的，虽然确实是不一致，但是确实可以产生订单，只有在库存减到1的时候才会出现超卖问题，所以可以设置update语句的where条件是库存大于0，那么当库存等于或者小于0的时候就不再扣减了，解决超卖问题。</p>
<p>另一个问题就是一人一单问题，这个问题的解决逻辑上是</p>
<p>判断该用户该是否已经有了该订单，如果存在就说返回一人只能下一单</p>
<p>但是可能会同一个人同时下单的情况，在判断的时候判断为没有下过单，然后进行了下单操作，是会有线程安全问题的，导致一人多单，线程问题肯定考虑加锁，加什么锁？由于是新增操作，所以是没有版本号给我们利用的，所以我们只能去考虑使用互斥锁了，ReentrantLock的话锁粒度太大了，不是所有线程都需要加锁的，所以考虑使用synchronized给用户id加锁，但是synchronized是jvm锁，在分布式下是会失效的。考虑使用分布式锁，可以使用redis来实现，setnx原理，不存在才会获得锁，其他的获取不到锁，就返回错误提示即可，这样锁的力度会很小。</p>
</blockquote>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://ssllp.github.io/2023/08/01/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/" title="Java面试题目合集" target="_blank" rel="external">https://ssllp.github.io/2023/08/01/Java面试题目合集/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/ssllp" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/ssllp" target="_blank"><span class="text-dark">ssllp</span><small class="ml-1x">Java开发</small></a></h3>
        <div>持续学习</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="vcomments"></div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2023/08/04/Git%E5%AD%A6%E4%B9%A0/" title="Git学习"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2023/07/30/Filmonline%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/" title="Filmonline开发手册"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn " data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">    <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  


</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/ssllp" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://weibo.com/" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
        <li><a href="https://www.behance.net/" target="_blank" title="Behance" data-toggle=tooltip data-placement=top><i class="icon icon-behance"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   




   
    
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine"></script>
  <script type="text/javascript">
  var GUEST = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link';
  meta = meta.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#vcomments',
    verify: false,
    notify: false,
    appId: '',
    appKey: '',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: meta,
    pageSize: '10' || 10,
    visitor: false
  });
  </script>

     







</body>
</html>